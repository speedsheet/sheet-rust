# <#>Rust<> SpeedSheet
<b>Find what you need, faster.<>


<table><col><b>Basics<>

<*><link "?q=hello+world">Hello World<>
<link "?q=fundamentals-only">Language Fundamentals<>
<link "?q=conventions-only">Naming Conventions<><>

<*><link "?q=attributes-only">Attributes<>
<link "?q=closure-only">Closures<>
<link "?q=control-structure-only">Control Structures<>
<link "?q=errors-only">Error Handling<>
<link "?q=file+io">File IO<>
<link "?q=functions-only">Functions<>
<link "?q=macro-only">Macros<>
<link "?q=module-only">Modules<>
<link "?q=operators-only">Operators<>
<link "?q=traits-only">Traits<><>

<b>Control Structures<>

<*><link "?q=if-else-only">If Else<>
<link "?q=ternary-only">If / Inline<>
<link "?q=for-only#for_-_basics">For Loop<>
<link "?q=loop-only">Loop<>
<link "?q=match-only#match_-_basics">Match<>
<link "?q=while-only#while_-_basics">While<><>

<b>Running Rust<>

<*><link "?q=command-line-only">Command Line<>
<link "?q=configuration-only">Configuration<><>

<b>Reference<>

<*><link "?q=online-docs-only">Online Docs<>
<link "?q=reserved-only">Reserved Words<>
<link "?q=terms-only">Rust Terms<>
<link "?q=symbols-only">Symbol Lookup<><>

<><col><b>Data Types<>

<*><link "?q=variables-only">Variables<>
<link "?q=ownership-only">Ownership<>
<link "?q=literals-only">Literals<>
<link "?q=data-types-only">Data Types<><>

<*><link "?q=boolean-only">Bool<>
<link "?q=byte-only">Byte<>
<link "?q=char-only">Char<>
<link "?q=float-only">Float<>
<link "?q=integer-only">Integer<>
<link "?q=str-only">Str<>
<link "?q=string-only">String<><>

<*><link "?q=reference-only">References / Pointers<><>

<*><link "?q=unit-only">Unit<>
<link "?q=box-only">Box<>
<link "?q=enum-only">Enum<>
<link "?q=option-only">Option<>
<link "?q=range-only">Range<><>

<*><link "?q=struct-only">Struct<>
<link "?q=tuple-only">Tuple<>
<link "?q=tuple-struct-only">Tuple Struct<><>

<*><link "?q=array-only">Array<>
<link "?q=hashmap-only">HashMap<>
<link "?q=vec-only">Vec<><><>



# Online Documents
@
@ links, online, online-docs-only, docs-only

### Rust Official Site
<l>https://www.rust-lang.org/<>

### Rust Documents
<l>https://doc.rust-lang.org/book/title-page.html<>
@
@ documentation

### Rust - Download / Install Page
<l>https://www.rust-lang.org/tools/install<>

### Rust - Online Playground
<l>https://play.rust-lang.org/<>

Code interactively on this page, no setup required.
@
@ repl, interactively

### Rust - Crates.io
<l>crates.io<>

The official Rust package registry.

### Rust - Rustup
<l>https://rustup.rs/<>



# Hello World

File Name:

<cb>main.rs<>

File Contents:

<cb>fn main() {
	println!("Hello world!");
}<>

Compile:

<cb>rustc main.rs<>

Run:

<cb>main<>
@
@ Examples



# Language Fundamentals
@
@ language-fundamentals-only, fundamentals-only



### Comments

<cb><#>// This is a comment.<><>

Start a comment with '<c>//<>'.
@
@ //



### Comments - Multiline

<cb><#>/*

Multiline Comment

*/<><>

Start a multiline comment with '<c>/*<>'.
End with '<c>*/>'
@
@ /*, */, /**/



### Doc Comments

<cb><#>/// This is a doc comment.<><>

<cb><#>/// This doc comment
/// adds content to the
/// following function.<>
fn <v>documented_function<>() {
	<v>...<>
}<>

Doc comments are placed before the item being commented on.
Use a triple forward slash (<#><c>///<><>) on each line.
@
@ code, documentation, docstring-only, docstr-only, doc-string-only, doc-str-only
@ ///



### Doc Comments - Markdown Format

<cb><#>/// # Heading 1
/// ## Heading 2
///
/// In **<b>bold<>** or __<b>bold<>__
/// In *<i>italics<>* or _<i>italics<>_
/// In ~~<->strikethrough<>~~
///
/// [Link](<l>http//speedsheet.io<>)<><>


Doc comments support CommonMark Markdown.

CommonMark:
<l>https://commonmark.org/help/<>
@
@ code, documentation, docstring-only, docstr-only, doc-string-only, doc-str-only
@ ///



### Block

<cb>{
	<v>...<>
}<>


A block of code with it's own scope separate from the local scope.


Example:

<cb>let <v>a<> = <v>10<>;

{
	let <v>a<> = <v>5<> + <v>a<>;
	println!("a = {}", <v>a<>);
}

println!("a = {}", <v>a<>);

<#>// Prints:
//
//    a = 15
//    a = 10<><>



### Block Expression

<cb>= {
	<v>...<>
	<v>return_value<>
}<>


Defines a block that returns a value.
Return a value like any other expression, leave the semicolon (;) off.


Example:

<cb>let <v>value<> = {
	<v>10<>_i32.pow(<v>2<>)
};

println!("value = {}", <v>value<>);

<#>// Prints: "value = 100"<><>



### Identifiers

<cb>( <v>letter<> | <v>unicode_letter<> | _ )   ( <v>digit<> | <v>letter<> | <v>unicode_letter<> | _ ) *<>

<cb>[_a-zA-Z<v>unicode<>][_0-9a-zA-Z<v>unicode<>]*<>

Case sensitive.

The first character must be an alphabet letter, unicode letter or underscore.
The first character can not be a digit.
All other characters can be alphabet letters, unicode letters, underscores or digits.
A single underscore ('_') is not allowed.


Examples:

<cb><v>_identifier
identifier
ÏãùÎ≥ÑÏûê
item_1<><>

Invalid:

<cb><v>_
3_items
üéà<><>
@
@ rust names, variable names, module names, class names
@ rules, Valid, Name, Correct



### Program Root File

For Applications:

<cb>src/main.rs<>


For Libraries:

<cb>src/lib.rs<>
@
@ main.rs, lib.rs



### Program Entry Point / Main Function

Application File:

<cb>main.rs<>

<cb>fn main() {

}<>
@
@ main(), main.rs



### Program Directory Structure

<cb>.<v>project_name<>/
‚îÇ
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ Cargo.lock
‚îÇ
‚îú‚îÄ‚îÄ .git/
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs | lib.rs
‚îÇ   ‚îî‚îÄ‚îÄ *.rs
‚îÇ
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ *.rs
‚îÇ
‚îî‚îÄ‚îÄ target/
	‚îÇ
	‚îú‚îÄ‚îÄ doc/
	‚îÇ   ‚îî‚îÄ‚îÄ current/
	‚îÇ       ‚îú‚îÄ‚îÄ index.html
	‚îÇ       ‚îî‚îÄ‚îÄ *.html
	‚îÇ
	‚îú‚îÄ‚îÄ debug/
	‚îÇ   ‚îî‚îÄ‚îÄ <v>project_name<>
	‚îÇ
	‚îî‚îÄ‚îÄ release/
		‚îî‚îÄ‚îÄ <v>project_name<><>



### Statement Terminator

<cb><v>statement<>;<>

Terminate commands with a semicolon.


Example:

<cb>println!("<v>This statement is terminated with a semicolon.<>");<>
@
@ ;, command, line



### Rust File Extension

<cb>.rs<>

<cb><v>filename<>.rs<>
@
@ .rs



### Rust Environment Variable - Cargo Home

<cb>CARGO_HOME<>

Locates the Cargo directory.

Typically:

<cb>$HOME/.cargo<>
@
@ RUSTUP_HOME
@ Rust Path, .cargo



### Rust Environment Variable - Rustup Home

<cb>RUSTUP_HOME<>

Locates the RustUp directory.

Typically:

<cb>$HOME/.rustup<>
@
@ RUSTUP_HOME
@ Rust Path, .rustup



### Runtime Data Types

Rust does not store data types at runtime.

Rust does not need to know the data types at runtime as the compiler has exhaustively checked that everything is correct.



# Install

Install Page:
<l>https://www.rust-lang.org/tools/install<>


### Rustup - Mac Homebrew - Install

From Terminal:

<cb>brew install rust<>

Formula:
<l>https://formulae.brew.sh/formula/rust<>


### Rustup - Linux / Mac - Install

From Terminal:

<cb>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh<>


### Rustup - Linux / Mac - Uninstall

<cb>rustup self uninstall<>



### Rust IDE - IntelliJ - Download

Official Download Site:
<l>https://www.jetbrains.com/idea/download<>



# Command-line
@
@ commandline, command line, cli, cli-only, command-line-only, commandline-only, commands-only



### Rust - Update

<cb>rustup update<>

Update to the latest version.
@
@ rustup, upgrade



### Rust - Version

<cb>rustc -V<>

<cb>rustc --version<>
@
@ rustc



## Cargo
@
@ cargo-only


### Cargo - Create Application

<cb>cargo new <v>application_name<><>

Creates a skeleton program complete with source folder, git files and Cargo.toml.

Creates a new directory for all these files.


Creates:

<cb><v>application_name<>/
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ .git/
‚îî‚îÄ‚îÄ src/
	‚îî‚îÄ‚îÄ main.rs<>
@
@ cargo new, skeleton, scaffolding, program, project



### Cargo - Create Application In Directory

<cb>cargo init<>


Creates a skeleton program complete with source folder, git files and Cargo.toml.

Creates the files in the current directory.


Creates:

<cb>./
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ .git/
‚îî‚îÄ‚îÄ src/
	‚îî‚îÄ‚îÄ main.rs<>
@
@ cargo new, skeleton, scaffolding, program, project, init



### Cargo - Create Library

<cb>cargo new --lib <v>library_name<><>

Creates a skeleton library complete with source folder, git files and Cargo.toml.


Creates:

<cb><v>library_name<>/
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ .git/
‚îî‚îÄ‚îÄ src/
	‚îî‚îÄ‚îÄ lib.rs<>
@
@ cargo new, skeleton, scaffolding



### Cargo - Build / Debug

<cb>cargo build<>

Compiles the program.

The build includes debugging code and will create a bigger, slower executable vs. the release version.


Directory:

<cb><v>project<>/
‚îî‚îÄ‚îÄ target/
	‚îî‚îÄ‚îÄ debug/<>
@
@ cargo, compile, create, executable



### Cargo - Build / Release

<cb>cargo build -r<>

<cb>cargo build --release<>

Compiles the program for release.

This strips all debugging code from the executable resulting in a faster, smaller build.


Directory:

<cb><v>project<>/target/release<>
@
@ cargo, compile, create, release, production, executable, -r, --release



### Cargo - Build / To Target

<cb>cargo build --target <v>target_name<><>


Creates an executable for the given target.

Requires the target be added with rustup.
@
@ cargo, compile, create, executable, --target
@ target-only, targets-only



### Cargo - Check Depedencies

<cb>cargo check<>

Checks that all the depedencies are present and have the correct versions.



### Cargo - Clean

<cb>cargo clean<>

Deletes the <c>target<> directory (contains the build and binary files).



### Cargo - Run

<cb>cargo run<>

Compiles and runs the application.
@
@ project, application



### Cargo - Run Tests

<cb>cargo test<>

Runs unit tests.

Tests Directory:

<cb><v>project<>/
‚îî‚îÄ‚îÄ tests/<>
@
@ project, application



### Cargo - Generate Assembly

<cb>cargo rustc -- --emit asm<>

or:

<cb>RUSTFLAGS="--emit asm" cargo build<>
@
@ --emit asm, rustc



### Cargo - Generate Docs

<cb>cargo doc<>

Converts Rust code doc comments and converts them into html.

Docs Directory:

<cb><v>project<>/
‚îî‚îÄ‚îÄ target/
	‚îî‚îÄ‚îÄ doc/
		‚îî‚îÄ‚îÄ current/<>



### Cargo - Generate Docs / Skip Dependency Check

<cb>cargo rustdoc<>

Converts Rust code doc comments and converts them into html.

rustdoc will not perform a dependency check before generating.

Docs Directory:

<cb><v>project<>/
‚îî‚îÄ‚îÄ target/
	‚îî‚îÄ‚îÄ doc/
		‚îî‚îÄ‚îÄ current/<>



## Cargo - Crates


### Cargo - Crate - Build Crate

<cb>cargo package<>

Creates a publishable crate.

Crate Directory:

<cb><v>project<>/
‚îî‚îÄ‚îÄ target/
	‚îî‚îÄ‚îÄ package/<>
@
@ package



### Cargo - Crate - Build Crate - Ignore Unchecked Files

<cb>cargo package --allow-dirty<>

Creates a publishable crate.

Ignores any files not checked into git.
@
@ package, --allow-dirty



### Cargo - Crate - Publish

<cb>cargo login <v>repository_authentication_token<>

cargo publish<>
@
@ publish, login



### Cargo - Crate - Yank

<cb>cargo yank --version <v>x<>.<v>x<>.<v>x<> <v>crate_name<><>



## Rustc


### Program - Compile Executable

<cb>rustc <v>program_name.rs<><>

Creates a binary file that can be executed.

Contains all compiler debug code and will create a relatively larger executable.
@
@ rustc, create binary



### Program - Compile Executable for Release

<cb>rustc -O <v>program_name.rs<><>

Creates a binary file that can be executed.

Creates a production ready version with compiler debug code removed.
@
@ rustc, create binary, -O



### Program - Compile Library

<cb>rustc --crate-type=lib <v>program_name.rs<><>

Creates a library file (extension .lib).
@
@ rustc, create, .lib



### Program - Compile Test

<cb>rustc --test <v>program_name.rs<><>
@
@ rustc, test, -t, --test



### Program - Run

<cb><v>program_name<><>

Run after compiling with <c>rustc<>.



### Program - Run Tests

<cb><v>program_name<><>

Run after compiling with <c>rustc --test<>.



## Rustup - Targets
@
@ target-only, targets-only
@ rustup-only


### Rustup - Target - Install Target

<cb>rustup target add <v>target_name<><>



### Rustup - Target - Install Target - MacOS x86

<cb>rustup target add x86_64-apple-darwin<>

Usage:

<cb>rustup target add x86_64-apple-darwin
cargo build --release --target x86_64-apple-darwin<>
@
@ apple, darwin
@ add, install
@ x86_64-apple-darwin



### Rustup - Target - Install Target - Raspberry Pi 4

<cb>rustup target add armv7-unknown-linux-gnueabihf<>

Usage:

<cb>rustup target add armv7-unknown-linux-gnueabihf
cargo build --release --target armv7-unknown-linux-gnueabihf<>


Requires:

<cb>arm-linux-gnueabihf-binutils<>

<cb>brew install arm-linux-gnueabihf-binutils<>
@
@ add, install
@ armv7-unknown-linux-gnueabihf, arm-linux-gnueabihf-binutils



### Rustup - Target - Install Target - Windows

<cb>rustup target add x86_64-pc-windows-gnu<>

Usage:

<cb>rustup target add x86_64-pc-windows-gnu
rustup toolchain install stable-x86_64-pc-windows-gnu
cargo build --release --target stable-x86_64-pc-windows-gnu<>


Requires:

<cb>stable-x86_64-pc-windows-gnu<>

<cb>brew install stable-x86_64-pc-windows-gnu

	<#># Or...<>

rustup toolchain install stable-x86_64-pc-windows-gnu<>
@
@ add, install
@ x86_64-pc-windows-gnu, stable-x86_64-pc-windows-gnu



### Rustup - Targets - List All

<cb>rustup target list<>


Lists all available targets.



# Configuration
@
@ cargo.toml, configuration-only


### Configuration File

<cb>Cargo.toml<>



### Configuration File - Sample

<cb><#># Comments<>

[package]
name = "<v>AppName<>"
version = "<v>v<>.<v>v<>.<v>v<>"
edition = "<v>yyyy<>"

[dependency]
<v>library_1<> = "<v>v<>.<v>v<>.<v>v<>"
<v>library_2<> = "^<v>v<>.<v>v<>"<>



# Compiler


### Silence Dead Code Warnings

<cb>#[allow(dead_code)]<>


Place in front of unused function.


Example:

<cb>#[allow(dead_code)]
fn <v>unused_function<>() {
	<v>...<>
}<>
@
@ #[allow(dead_code)], allow dead_code



# Operators
@
@ Operators, Operations, Expressions
@ operators-only


## Arithmetic Operators

<in><table><col><c><v>a<> + <v>b<><>    <><col>Add<>
<col><c><v>a<> - <v>b<><><><col>Subtract<>
<col><c><v>a<> * <v>b<><><><col>Multiply<>
<col><c><v>a<> / <v>b<><><><col>Divide<>
<col><c><v>a<> % <v>b<><><><col>Modulo / Remainder<><><>
@
@ +, -, *, /, %
@ add, plus, subtract, minus, multiply, divide, modulo, modulus



## Arithmetic Assignment Operators

<in><table><col><c><v>a<> += <v>b<><>   <><col>Add<>
<col><c><v>a<> -= <v>b<><><><col>Subtract<>
<col><c><v>a<> *= <v>b<><><><col>Multiply<>
<col><c><v>a<> /= <v>b<><><><col>Divide<>
<col><c><v>a<> %= <v>b<><><><col>Modulo / Remainder<><><>

Calculate the operation and save the result in <c><v>a<><>.
@
@ +=, -=, *=, /= %=
@ add, plus, subtract, minus, multiply, divide, modulo, modulus



## Bitwise Operators

<in><table><col><c>!<v>a<><><><col>Complement / Inverse<>
<col> <>
<col><c><v>a<> & <v>b<><><><col>Bitwise AND<>
<col><c><v>a<> | <v>b<><><><col>Bitwise OR<>
<col><c><v>a<> ^ <v>b<><><><col>Bitwise XOR<>
<col> <>
<col><c><v>a<> \<\< <v>shift_count<><><><col>Bitwise Shift Left<>
<col><c><v>a<> >> <v>shift_count<><><><col>Bitwise Shift Right<><><>
@
@ !, &, |, ^, \<\<, >>, binary
@ shift left, shift right



## Bitwise Assignment Operators

Calculate the operation and save the result in <c><v>a<><>:

<in><table><col><c><v>a<> &= <v>b<><><><col>Bitwise AND<>
<col><c><v>a<> |= <v>b<><><><col>Bitwise OR<>
<col><c><v>a<> ^= <v>b<><><><col>Bitwise XOR<>
<col> <>
<col><c><v>a<> \<\<= <v>shift_count<><><><col>Bitwise Shift Left<>
<col><c><v>a<> >>= <v>shift_count<><><><col>Bitwise Shift Right<><><>
@
@ &=, |=, ^=, \<\<=, >>=, binary
@ and, or, xor, shift left, shift right



## Comparison Operators

<in><table><col><c><v>a<> == <v>b<><>     <><col>Equals<>
<col><c><v>a<> != <v>b<><><><col>Not Equals<>
<col><c><v>a<> > <v>b<><><><col>Greater Than<>
<col><c><v>a<> \< <v>b<><><><col>Less Than<>
<col><c><v>a<> >= <v>b<><><><col>Greater Than or Equals<>
<col><c><v>a<> \<= <v>b<><><><col>Less Than or Equals<><><>
@
@ Boolean, ==, !=, \<>, \<, \<=, >, >/
@ less than, greater than, less that or equal, greater than or equal, compare



## Logical Operators

<in><table><col><c>!<v>a<><><><col>Not<>
<col> <>
<col><c><v>a<> && <v>b<><><><col>And<>
<col><c><v>a<> || <v>b<><><><col>Or<><><>
@
@ Boolean, !, &&, ||
@ and, or, not, negation, bang



## Ternary Operator / Inline If

<cb>= if <v>expression<> { <v>true_value<> } else { <v>false_value<> }<>

Full Form:

<cb>let <v>value<> = if <v>expression<> { <v>true_value<> } else { <v>false_value<> };<>


Evaluates a conditional if expression to a value.
Must be terminated with a semicolon (;).


Example:

<cb>let <v>a<> = 10;
let <v>more_or_less<> = if <v>a<> > 5 {"more"} else {"less"};

println!("{} is {} than 5.", <v>a<>, <v>more_or_less<>);

<#>// Prints "10 is more than 5."<><>
@
@ Ternary conditional operator, tertiary, expression
@ Inline If, iif, if else
@ ternary-only



## Operator Precedence

Highest to Lowest:

<card><table><col><b>Operator / Expression<><><col><b>Associativity<><>
<col> <>
<col>Path<>
<col>Method Call<>
<col>Field Expression<><col>Left to Right<>
<col>Function Call / Array Index<>
<col>?<>
<col>Unary <c>-<>,  <c>*<>,  <c>!<> <c>&<>,  <c>&mut<><>
<col><c>as<><><col>Left to Right<>
<col><c>*<>,  <c>/<>,  <c>%<><><col>Left to Right<>
<col><c>+<>,  <c>-<><><col>Left to Right<>
<col><c>\<\<<>,  <c>>><><><col>Left to Right<>
<col><c>&<><><col>Left to Right<>
<col><c>^<><><col>Left to Right<>
<col><c>|<><><col>Left to Right<>
<col><c>==<>,  <c>!=<>,  <c>\<<>,  <c>><>,  <c>\<=<>,  <c>>=<><><col>Parentheses Required<>
<col><c>&&<><><col>Left to Right<>
<col><c>||<><><col>Left to Right<>
<col><c>..<>,  <c>..=<><><col>Parentheses Required<>
<col><c>=<>,  <c>+=<>,  <c>-=<>,  <c>*=<>,  <c>/=<>,  <c>%=<>,  <c>&=<>,  <c>|=<>,  <c>^=<>,  <c>\<\<=<>,  <c>>>=<><><col>Left To Right<>
<col><c>return<>,  <c>break<>,  closures<><><>
@
@ order of operations



# Control Structures
@
@ statements, flow
@ control-only, control-structure-only, control-structures-only
@ control-statements-only



## Control Structures - Basics

<table><col>If Else     <><col><c>if <v>expression<> {
	<v>...<>
}<><>
<col> <>
<col> <>
<col><><col><c>if <v>expression<> {
	<v>...<>
}
else if <v>expression<> {
	<v>...<>
}
else {
	<v>...<>
}<><>
<col> <>
<col> <>
<col>For<><col><c>for <v>value<> in <v>start<>..<v>end_plus_one<> {
	<v>...<>
}<><>
<col> <>
<col> <>
<col><><col><c>for <v>value<> in <v>start<>..=<v>end<> {
	<v>...<>
}<><>
<col> <>
<col> <>
<col><><col><c>for <v>value<> in <v>iterator<> {
	<v>...<>
}<><>
<col> <>
<col> <>
<col>Loop<><col><c>loop {
	<v>...<>
}<><>
<col> <>
<col> <>
<col><><col><c>loop {
	<v>...<>
	continue;
	<v>...<>
	break;
	<v>...<>
}<><>
<col> <>
<col> <>
<col>Match<><col><c>match <v>item<> {
	<v>value_1<> => {
		<v>...<>
	}
	<v>value_2<> | <v>value_3<> => {
		<v>...<>
	}
	<v>min_1<>..<v>max_plus_one_1<> => {
		<v>...<>
	}
	<v>bind_value<> @ <v>min_2<>..<v>max_plus_one_2<> => {
		<v>...<>
	}
	_ => {
		<v>...<>
	}
}<><>
<col> <>
<col> <>
<col>While<><col><c>while <v>expression<> {
	<v>...<>
}<><><>



## If Else
@
@ else, if-only, if-else, if-else-only


### If Else


<cb>if <v>expression<> {
	<v>...<>
}<>

<cb>if <v>expression<> {
	<v>...<>
}
else if <v>expression<> {
	<v>...<>
}
else {
	<v>...<>
}<>


Example:

<cb>let <v>value<> = 42;

if <v>value<> \< 42 {
	println!("{} is less than 42.", <v>value<>);
}
else if <v>value<> == 42 {
	println!("{} is 42.", <v>value<>);
}
else  {
	println!("{} is greater than 42.", <v>value<>);
}<>



### If Else - If Let
,
<cb>if let <v>value<> = <v>expression<> {
	<v>...<>
}
else {
	<v>...<>
}<>


Equivalent To:

<cb>match <v>expression<> {
	<v>value<> => {
		<v>...<>
	}
	_ => {
		<v>...<>
	}
}<>


Use where you need to test for a single value of an enum and instead of using a more verbose match statement.
(eg: where Some() is involved)

Uses <c>let<>'s refutability test.


Example:

<cb>let <v>numbers<> = [Some(1), None, Some(3), None, Some(5)];

for <v>number<> in <v>numbers<> {

	if let Some(<v>value<>) = <v>number<> {
		println!("{}", <v>value<>);
	}
	else {
		println!("[none]");
	}
}

<#>// Prints:
//
// 1
// [none]
// 3
// [none]
// 5<><>


## For
@
@ for-only, fors-only, for-in, for-in-only



### For - In Range

<cb>for <v>value<> in <v>start<>..<v>end_plus_one<> {
	<v>...<>
}<>

<cb>for <v>value<> in <v>start<>..=<v>end<> {
	<v>...<>
}<>


Example:

For With <c>..<> :

<cb>for <v>value<> in <v>0<>..<v>3<> {
	println!("{}", <v>value<>);
}

<#>// Prints Values: 0, 1, 2<><>

For With <c>..=<> :

<cb>for <v>value<> in <v>0<>..=<v>3<> {
	println!("{}", <v>value<>);
}

<#>// Prints Values: 0, 1, 2, 3<><>
@
@ .., ..=



### For - In Collection

<cb>for <v>value<> in <v>collection<> {
	<v>...<>
}<>


Iterates over each item in the collection using its iterator.


Example:

<cb>let <v>vec_1<> = vec!["<v>one<>", "<v>two<>", "<v>three<>"];

for <v>item<> in <v>vec_1<> {
	println!("{} ", <v>item<>);
}

<#>// Prints:
//
//    one
//    two
//    three<><>
@
@ foreach, for-each, collection, .iter()



### For - In Iterator

<cb>for <v>value<> in <v>iterator<> {
	<v>...<>
}<>


Iterates over each item in the iterator.


Example:

<cb>let <v>vec_1<> = vec!["<v>one<>", "<v>two<>", "<v>three<>"];
let <v>iterator<> = <v>vec_1<>.iter();

for <v>item<> in <v>iterator<> {
	println!("{} ", <v>item<>);
}

<#>// Prints:
//
//    one
//    two
//    three<><>
@
@ iterator, iterate



### For - Break, Continue

<cb>for <v>...<> {
	<v>...<>
	continue;
	<v>...<>
	break;
	<v>...<>
}<>



## Loop
@
@ loop-only, loops-only


### Loop

<cb>loop {
	<v>...<>
}<>

<cb>loop {
	<v>...<>
	continue;
	<v>...<>
	break;
	<v>...<>
}<>


Loops continuously until break is called.
Use to create an infinite loop.


Example:

<cb>let mut <v>value<> = <v>0<>;

loop {
	<v>value<> += 1;
	println!("{}", <v>value<>);

	if <v>value<> > 4 {
		break;
	}
}

<#>// Prints values 1, 2, 3, 4.<><>
@
@ break, continue, infinite



### Loop - Loop Expression / Return Value

<cb>let <v>returned_value<> = loop {
	<v>...<>
	break <v>return_value<>;
	<v>...<>
};<>


Loops and then returns a value on break.

Loops continuously until break is called.
Requires a semicolon (;) after the block.


Example:

<cb>let mut <v>value<> = <v>0<>;

let <v>result<> = loop {

	<v>value<> += 1;
	if <v>value<> > 4 {
		break <v>value<>;
	}
};

println!("Result = {}.", <v>result<>);

<#>// Prints: "Result = 5."<><>
@
@ break
@ loop-only, expression, with return value



### Loop - Named / Nested Loop

<cb>'<v>name<>: loop {
	<v>...<>
	continue <v>name<>;
	<v>...<>
	break <v>name<>;
	<v>...<>
}<>

Nested:

<cb>'<v>outer_name<>: loop {

	'<v>inner_name<>: loop {
		<v>...<>
		continue <v>outer_name<>;
		<v>...<>
		break <v>outer_name<>;
		<v>...<>
	}
}<>


Labels each loop with a name.
Allows break and continue statements to operate on an outer loop.
@
@ break, continue, labeled


## Match
@
@ match-only, matches-only


### Match - Basics

<cb>match <v>item<> {
	<v>value_1<> => {
		<v>...<>
	},
	<v>value_2<> | <v>value_3<> => {
		<v>...<>
	},
	<v>min_1<>..<v>max_plus_one_1<> => {
		<v>...<>
	},
	<v>bind_value<> @ <v>min_2<>..<v>max_plus_one_2<> => {
		<v>...<>
	},
	_ => {
		<v>...<>
	}
}<>

Match Expression:

<cb>let <v>value<> = match <v>item<> {
	<v>value_1<> => { <v>...<> },
	<v>value_2<> => { <v>...<> }
};<>


### Match - Details


#### Match - Single Value

<cb>match <v>item<> {
	<v>value_1<> => {
		<v>...<>
	},
	<v>value_2<> => {
		<v>...<>
	},
	_ => {
		<v>...<>
	}
}<>



#### Match - Multiple Values

<cb>match <v>item<> {
	<v>value_1<> | <v>value_2<> => {
		<v>...<>
	},
	<v>value_3<> | <v>value_4<> => {
		<v>...<>
	},
	<v>...<>
}<>



#### Match - Value Range

<cb>match <v>item<> {
	<v>min<>..<v>max_plus_one<> => {
		<v>...<>
	},
	<v>min<>..=<v>max<> => {
		<v>...<>
	},
	<v>...<>
}<>



#### Match - Bind To Value

<cb>match <v>item<> {
	<v>bind_value<> @ <v>min_2<>..<v>max_plus_one_2<> => {
		<v>...<>
	},
	<v>...<>
}<>



#### Match - Match Expression

Match Expression:

<cb>let <v>value<> = match <v>item<> {
	<v>value_1<> => { <v>...<> },
	<v>value_2<> => { <v>...<> },
	<v>...<>
};<>


Returns a value from a match expression.


Example:

<cb>let <v>value<> = 200;

let <v>returned_value<> = match <v>value<> {
	200 => { "OK" },
	400 => { "Bad Request" },
	500 => { "Server Error" },
	_ => { "Unknown" }
};

println!("Returns {}.", <v>returned_value<>);

<#>// Prints ""><><>
@
@ return value



### Match - Match Enum

<cb>match <v>enum_value<> {
	Enum1::Value1 => { <v>...<> },
	Enum1::Value2 => { <v>...<> },
	Enum1::Value3 => { <v>...<> },
	<v>...<>
};<>
@
@ enums



### Match - Match Enum Tuple

<cb>match <v>enum_value<> {
	Enum1::Value1 (<v>field_1<>) => { <v>...<> },
	Enum1::Value2 (<v>field_2<>) => { <v>...<> },
	Enum1::Value3 (<v>field_3<>, <v>field_4<>) => { <v>...<> },
	<v>...<>
};<>
@
@ enums, fields, values, elements



### Match - Match Enum Struct

<cb>match <v>enum_value<> {
	Enum1::Value1 {<v>field_1<>} => { <v>...<> },
	Enum1::Value2 {<v>field_2<>} => { <v>...<> },
	Enum1::Value3 {<v>field_3<>, <v>field_4<>} => { <v>...<> },
	<v>...<>
};<>
@
@ enums, fields, values, elements



## While
@
@ while-only



### While

<cb>while <v>expression<> {
	<v>...<>
}<>

Loops until the expression evaluates to true.


Example:

<cb>let mut <v>value<> = 0;

while <v>value<> \< 5 {
	println!("{}", <v>value<>);
	<v>value<> += 1;
}

<#>\\ Prints values 0, 1, 2, 3, 4.<><>



### While - Break, Continue

<cb>while <v>expression<> {
	<v>...<>
	continue;
	<v>...<>
	break;
	<v>...<>
}<>



### While - While Let

<cb>while let <v>value<> = <v>item<> {{
	<v>...<>
}<>



# Literals
@
@ literals-only, lit-only, literal-only


## Literals - Basics

<table><col>= <c>true | false<><><col>Boolean Literal<><col><c>bool<><>
<col> <>
<col><c>= <v>11<><><><col>Decimal Literal<><col>Integer<>
<col><c>= <v>-11<><><><col>Decimal Literal<><col>Integer<>
<col><c>= <v>11<>_i32<><><col>Decimal Literal<><col>Integer / i32<>
<col><c>= <v>12_345<><><><col>Decimal Literal<><col>Integer<>
<col> <>
<col><c>= 0b<v>1111_0000<><><><col>Binary Literal<><col>Integer<>
<col><c>= 0x<v>ff<><><><col>Hex Literal<><col>Integer<>
<col><c>= 0o<v>77<><><><col>Octal Literal<><col>Integer<>
<col> <>
<col><c>= <v>11.23<><><><col>Float Literal<><col>Float<>
<col><c>= <v>-11.23<><><><col>Float Literal<><col>Float<>
<col><c>= <v>11.23<>_f64<><><col>Float Literal<><col>Float / f64<>
<col><c>= <v>12_345.23_45<><><><col>Float Literal<><col>Float<>
<col> <>
<col><c>= b'<v>C<>'<><><col>Byte Literal<><col><c>u8<><>
<col> <>
<col><c>= '<v>c<>'<><><col>Character Literal<><col><c>char<><>
<col><c>= "<v>string<>"<><><col>String Literal<><col><c>str<><>
<col> <>
<col><c>= [<v>item_1<>, <v>item_2<>, <v>item_3<>]<><><col>Array<>
<col><c>= (<v>item_1<>, <v>item_2<>, <v>item_3<>)<><><col>Tuple<><>

Integer - One of:

<in><c>i8, i16, i32, i64, i128, isize
u8, u16, u32, u64, u128, usize<><>

Float - One of:

<in><c>f32, f64<><>



## Literals - Details


### Boolean Literal

<cb>= true<>

<cb>= false<>

Returns:

<cb>bool<>
@
@ true, false



### Byte Literals

<cb>= b'<v>A<>'<>

Returns:

<cb>u8<>
@
@ b'', u8



### Character Literal

<cb>= '<v>c<>'<>

Returns:

<cb>char<>
@
@ '', char



### Float Literal

<cb>= <v>11.23<><>

<cb>= <v>-11.23<><>

<cb>= <v>12_345.67<><>

Type Explicitly Declared:

<cb>= <v>11.23<>f32<>

<cb>= <v>11.23<>_f32<>

Returns: Float Type

The return type depends on the type inference engine or the declared variable type but must be a float type.

@
@ f64, f32



### Integer Literal

<cb>= <v>11<><>

<cb>= <v>-11<><>

<cb>= <v>12_345<><>

Type Explicitly Declared:

<cb>= <v>11<>i32<>

<cb>= <v>11<>_i32<>

Returns: Integer Type

The return type depends on the type inference engine or the declared variable type.



### Integer Literal - Binary

<cb>= 0b<v>1100<><>

<cb>= 0b<v>_1111_0000<><>

Returns: Integer Type

The return type depends on the type inference engine or the declared variable type.
@
@ 0b



### Integer Literal - Hex

<cb>= 0x<v>ff<><>

Returns: Integer Type

The return type depends on the type inference engine or the declared variable type.
@
@ 0x



### Integer Literal - Octal

<cb>= 0o<v>77<><>

Returns: Integer Type

The return type depends on the type inference engine or the declared variable type.
@
@ 0o



### String Literal

<cb>= "<v>A String<>"<>

Returns:

<cb>str<>

Stored in the code.
@
@ "", str



### String Literal - Escapes

<cb>"\\<v>x<>"<>

<table><col>Escape Syntax<><col><c>\\<v>x<><><>
<col> <>
<col>Backslash<><col><c>\\\\<><>
<col>Carriage Return<><col><c>\\r<><>
<col>Newline<><col><c>\\n<><>
<col>Tab<><col><c>\\t<><>
<col> <>
<col>Null<><col><c>\\0<><><>
@
@ tab, newline, backslash, carriage return, null



### String Literal - Escaped Character

<cb>"\\x<v>ff<>"<>


Defines an 8-bit character.

Equivalent:

<cb>= "\\x<v>65<>"

= "A"<>
@
@ ascii code



### String Literal - Escaped Unicode Character

<cb>"\\x{<v>ffff<>}"<>

Equivalent:

<cb>= "\\x<v>65<>"

= "A"<>



### String Literal - Multiline

<cb>= "<v>Line 1
Line 2
Line 3<>"<>

Returns:

<cb>str<>


Returns a multiline string.

Use a normal string literal with embedded new lines to create a multiline string. 
@
@ "", str



### String Literal - Raw Escape

<cb>r"<#>text<>"
r#"<#>text<>"#
r###"<#>text<>"###<>

Examples:

<cb>= "<#>Text \\t using escapes.<>"			<s>// \\t -> tab character<>
= r"<#>Text \\t ignoring escapes<>"		<s>// \\t -> "\\t" (unchanged)<>

= "<#>Quotes \\" \\" requiring escapes.<>"
= r#"<#>Qoutes " " without escapes.<>"#

= r##"<#>Qoutes " " and single # hashes # without escapes.<>"##<>
@
@ r", r#", r##"



# Variables
@
@ vars-only, var-only, variable-only, variables-only, assignment


## Variables - Basics

Declare Only:

<cb>let <v>name<>: <v>type<>;<>

Constant:

<cb>const <v>name<>: <v>type<> = <v>value<>;<>

Immutable:

<cb>let <v>name<>: <v>type<> = <v>value<>;<>

With Type Inferencing:

<cb>let <v>name<> = <v>value<>;<>

Mutable:

<cb>let mut <v>name<>: <v>type<> = <v>value<>;<>

Update Mutable:

<cb><v>name<> = <v>new_value<>;<>



## Variable - Create
@
@ Create, New


### Variable - Constant - Create

<cb>const <v>name<>: <v>type<> = <v>value<>;<>


Defines a constant, an immutable variable.

Constants can be declared globally outside a function.
The type must be declared (no type inferencing).

The compiler replaces the constant identifier with the actual value at compile time.


Example:

<cb>const <v>OK_STATUS_CODE<>: i32 = 200;

fn main() {
	println!("OK Status = {}", <v>OK_STATUS_CODE<>);
}
<>
@
@ const, global

println!("Value is {}.", <v>value<>);<>



### Variable - Local - Create

<cb>let <v>name<>: <v>type<> = <v>value<>;<>

<cb>let <v>name<> = <v>value<>;<>


Creates an immutable variable.

If the type is not included, the inference engine will try to determine it from the use of the variable.


Example:

<cb>let <v>int_1<>: i32 = 42;<>
@
@ immutable, let, scope#



### Variable - Static - Create

<cb>static <v>STATIC_1<>: <v>type<> = <v>value<>;<>


Creates a global immutable variable.

Static data is stored in the compiled binary.
Statics can be created inside or outside functions.
You <b>must<> declare the type for a static variable (no type inferencing).


Example:

<cb>static <v>INT_1<>: i32 = 42;

println!("{}", <v>INT_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/keyword.static.html">Static<>
@
@ immutable, static, global, scope



### Variable - Static - Create With 'static

<cb>static <v>STATIC_1<>: &'static <v>type<> = &<v>value<>;<>


Creates a global immutable variable.

<c>'static<> indicates the value lives for the entire life of the program.

Static data is stored in the compiled binary.
Statics can be created inside or outside functions.
You must declare the type for a static variable (no type inferencing).


Examples:

<cb>static <v>INT_1<>: &'static i32 = &42;

println!("{}", <v>INT_1<>);

<#>// Prints: "42"<><>

<cb>static <v>STR_1<>: &'static str = "42";

println!("{}", <v>STR_1<>);

<#>// Prints: "42"<><>
@
@ static, 'static
@ immutable, static, global, scope



### Variable - Mutable - Create

<cb>let mut <v>name<>: <v>type<> = <v>value<>;<>


Creates a mutable variable.


Example:

<cb>let mut <v>int_1<>: i32 = 42;
<v>int_1<> = int_1 + 10;<>
@
@ let, mut



### Variable - Create With Type Inferencing

<cb>let <v>name<> = <v>value<>;<>


This will create a variable of type matching the value.


Example:

<cb>let <v>int_1<> = 42;

<#>// Assigns int_1 as type i32;<><>
@
@ let



### Variable - Define Before Use

<cb>let <v>name<>: <v>type<>;<>

<cb>let mut <v>name<>: <v>type<>;<>


Define a variable before assiging a value.
The value must be assigned at some point afterwards.


Example:

<cb>let <v>value<>:i32;

let <v>flag<> = true;

if <v>flag<> {
	<v>value<> = 1;
}
else {
	<v>value<> = -1;
}

<#>// Sets value to 1.<><>
@
@ predefine



## Variable Operations



### Variable - Cast

<cb>= <v>value<> as <v>type<><>


Converts a value from one type to another.

Casting never happens implicitly.
You must always explicitly cast your variables.


Example:

<cb>let <v>value<> = 10_i32;

<v>value_i8<> = <v>value<> as i8;

println!("Value is {}", <v>value_i8<>)<>
@
@ as type, change, convert, conversion



### Variable - Memory Size

<cb>= size_of_val(&<v>value_1<>)<>

<cb>use std::mem::size_of_val;

= size_of_val(&<v>value_1<>)<>


Returns the memory used by a variable in bytes.


Example:

<cb>use std::mem::size_of_val;

let <v>value<>: i64 = <v>42<>;

println!("Size of value = {}.", size_of_val(&<v>value<>));

<#>// Prints: "Size of value = 8."<><>
@
@ get, retrieve, std::mem::size_of_val(), size_of_val()



### Variable - Type - Get Type

<cb>= type_name::\<<v>T<>>()<>

Use as a Function:

<cb>use std::any::type_name;

fn type_of\<<v>T<>>(_: <v>T<>) -> &'static str {
	type_name::\<<v>T<>>()
}

let <v>type_1<> = type_of(<v>variable_1<>);<>


Returns the variable type as a string.

Not guaranteed to give consistent results.
Use for testing only.


Example:

<cb>use std::any::type_name;

fn type_of\<<v>T<>>(_: <v>T<>) -> &'static str {
	type_name::\<<v>T<>>()
}

let <v>type_name<> = type_of(<v>1<>_i32);
println! ("Type = {}", <v>type_name<>);

<#>// Prints "Type = i32"<><>
@
@ std::any::type_name, type_name, get, retrieve, type of



## Variable Scope


### Variable Scope - Basics

Global, Local, Block:

<cb>static <v>global_variable<>:i32 = 1;

fn <v>func1<>() {

	let <v>local_variable<> = 2;

	{
		let <v>block_variable<> = 3;
	}
}<>

Shadowing:

<cb>fn <v>func1<>() {

	let <v>variable_1<> = 1;

	{
		<#>// Block, Shadows Outer Variable:<>
		let <v>variable_1<> = 2;
	}
}<>



### Variable Scope - Shadowing

Shadowing happens when a block variable overshadows a local variable of the same name.
The local variable is not accessable while the block variable is in scope.

Global (static) variables can NOT be shadowed.


Example:

<cb>let <v>a<> = <v>1<>;
println!("local a = {}", <v>a<>);

{
	let <v>a<> = <v>2<>;
	println!("block a = {}", <v>a<>);
}

println!("local a = {}", <v>a<>);<>



## Variables - let vs const vs static

let:

<in>Defines a variable with local scope.<>

static:

<in>Defines a variable with global scope.<>

const:

<in>Defines a value.
The compiler replace every use of the constant with the actual value at compile time.<>
@
@ versus, scope



## Let - Refutability Test

Let runs a refutability test before assigning a value.

It checks to see if the new value is (or can be) different to the current value.
If is different, then it is <b>refutable<>.
If not, it is <b>irrefutable<>.

<card><table><col>Refutable		<><col>Returns <c>true<><>
<col>Irrefutable<><col>Returns <c>false<><><><>
@
@ refutable, irrefutable



# Ownership
@
@ ownership-only


### Ownership - Rules

1. Resources have one and only one owner.
2. When the owner goes out of scope, the resource is freed.
3. Ownership is movable (transferable).

Ownership only applies to items on the heap.



### Ownership - Borrow

<cb>&<v>owner<><>

By Assignment:

<cb>let <v>borrower<> = &<v>owner<>;<>

When Passing:

<cb><v>function_1<>(&<v>owner<>);<>


Borrow (pass) a resource without passing ownership of it.

Use ampersand (<c>&<>) to denote borrowing.
There is no limit on the number of borrowers for an immutable resource.


Examples:

<cb>let <v>owner<> = Box::new(<v>42<>_i32);

let <v>borrower<> = &<v>owner<>;

println!("{}", &<v>owner<>);
println!("{}", <v>borrower<>);

<#>// Prints:
//
//    "42"
//    "42"<><>
@
@ &, borrowing



### Ownership - Borrow Mutable

<cb>&mut <v>owner<><>

By Assignment:

<cb>let <v>borrower<> = &mut <v>owner<>;<>

When Passing:

<cb><v>function_1<>(&mut <v>owner<>);<>


Borrow (pass) a mutable resource without passing ownership of it.

Use ampersand mut (<c>&mut<>) to denote borrowing.
There can only be one mutable borrower at a time for a mutable resource.
There can be any number of immutable borrowers, but if there are, no mutable borrowers are allowed.


Examples:

<cb>let mut <v>owner<> = Box::new(<v>42<>_i32);

let <v>borrower<> = &mut <v>owner<>;

println!("{}", <v>borrower<>);

<#>// Prints:
//
//    "42"
//    "42"<><>
@
@ &, mut



### Ownership - Moving Ownership

By Assignment:

<cb>let <v>new_owner<> = <v>owner<>;<>

When Passing:

<cb><v>function_1<>(<v>owner<>);<>


Passes ownership of the resource to the new variable or to the called function.

After a move, <v>owner<> can not be referenced.


Examples:

By Assignment:

<cb>let <v>owner<> = Box::new(<v>42<>_i32);

let <v>new_owner<> = <v>owner<>;

<#>// NO:
// println!("{}", owner);<>

<#>// YES:<>
println!("{}", <v>new_owner<>);

<#>// Prints: "42"<><>

By Passing:

<cb>fn <v>take_ownership<>(<v>value<>: Box\<i32>) {
	println!("{}", <v>value<>);
}

let <v>owner<> = Box::new(<v>42<>_i32);

<v>take_ownership<>(<v>owner<>);
<#>// Prints: "42"<>

<#>// NO!
// println!("{}", owner);<><>
@
@ move, take



# Types


### Type - Type Aliasing

<cb>type <v>Alias1<> = <v>Type<>;<>


Allows you to create an alias for a type for readability.


Example:

<cb>type <v>Kilometers<> = usize;

let <v>distance<>: <v>Kilometers<> = 42;<>
@
@ define custom type, assign



### Type - Type Aliasing With Generics

<cb>type <v>Alias1<>\<<v>T<>> = <v>Type<>\<<v>T<>, <v>...<>>;<>


Allows you to create an alias for a type with generics for readability.


Example:

<cb>type <v>MyResult<>\<<v>T<>> = Result\<<v>T<>, <v>MyError<>>;<>
@
@ define custom type, assign



### Type - Type Inferencing

Rust determines the variable type by looking ahead to see how it is used.
It then creates variable of the correct type.

Note:
You must use the correct literal types. You can not substitute integers for floats or vice versa.


Example:

Infer type of <c><v>value<><>:

<cb><#>// Infers value as i64:<>

fn <v>square<>(<v>x<>: i64) -> i64 {
	<v>x<> * <v>x<>
}

fn main() {

	<#>// Infer type:<>
	let <v>value<> = <v>4<>;

	<#>// Inference happens here: i64<>
	let <v>square<> = square(<v>value<>);

	println!("{} squared is {}.", <v>value<>, <v>square<>);
}<>



# Data Types
@
@ standard, builtin, data-types-only


## Primitive Types

<m>(See: <l>https://doc.rust-lang.org/book/ch03-02-data-types.html<>)<>

<table><col><c>bool<><><col>Boolean<>
<col> <>
<col><c>i8<><><col>Integer, 8-bit Signed<>
<col><c>i16<><><col>Integer, 16-bit Signed<>
<col><c>i32<><><col>Integer, 32-bit Signed<>
<col><c>i64<><><col>Integer, 64-bit Signed<>
<col><c>i128<><><col>Integer, 128-bit Signed<>
<col> <>
<col><c>u8<><><col>Integer, 8-bit Unsigned<>
<col><c>u16<><><col>Integer, 16-bit Unsigned<>
<col><c>u32<><><col>Integer, 32-bit Unsigned<>
<col><c>u64<><><col>Integer, 64-bit Unsigned<>
<col><c>u128<><><col>Integer, 128-bit Unsigned<>
<col> <>
<col><c>f32<><><col>Float, 32-bit Single Precision<>
<col><c>f64<><><col>Float, 64-bit, Double Precision<>
<col> <>
<col><c>char<><><col>Character<>
<col><c>str<><><col>String<>
<col> <>
<col><c>array<><><col>Array<>
<col><c>tup<><><col>Tuple<>
<col><c>slice<><><col>Slice (view into a sequence)<>
<col> <>
<col><c>fn<><><col>Function<>
<col> <>
<col><c>pointer<><><col>Raw, Unsafe Pointer<>
<col><c>ref<><><col>Reference, Shared or Mutable<>
<col> <>
<col><c>unit<><><col>Unit, () Type<><>


Floats: IEEE-754 Standard.

Rust Docs: <l https://doc.rust-lang.org/std/#primitives<>Primitives<>
@
@ integer, float, standard


## Primitive Collection Types

<table><col><c>[]<><><col>Array (Immutable List)<>
<col><c>[<v>T<>]<><><col>Slice<>
<col><c>()<><><col>Tuple (Immutable Compound Data Type)<><>



## Standard Collection Types

<table><col><c>BinaryHeap\<<v>T<>><><><col>Priority Queue<>
<col><c>BTreeMap\<<v>K<>, <v>V<>><><><col>Sorted Key Value Map<>
<col><c>BTreeSet\<<v>T<>><><><col>Sorted Set<>
<col><c>HashMap\<<v>K<>, <v>V<>><><><col>Key Value Map<>
<col><c>HashSet\<<v>T<>><><><col>Set<>
<col><c>LinkedList\<<v>T<>><><><col>Double Linked List<>
<col><c>Vec\<<v>T<>><><><col>Vector (Mutable List)<>
<col><c>VecDeque\<<v>T<>><><><col>Double Ended Queue<><>



## Standard Enum Types

<table><col><c>Option\<<v>T<>><><><col>Option<>
<col><c>Result\<<v>T<>, <v>E<>><><><col>Result<><>



# Boolean

<cb>= true
= false<>

<cb>let <v>bool_1<> = true;<>

<cb>let <v>bool_1<>: bool = true;<>

Type:

<cb>bool<>


Creates a boolean variable.


Examples:

With Type Literals:

<cb>let <v>bool_1<> = true;

println!("{}", <v>bool_1<>);

<#>// Prints: "true"<><>

With Type Declaration:

<cb>let <v>bool_1<>: bool = <v>false<>;

println!("{}", <v>bool_1<>);

<#>// Prints: "false"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.bool.html">bool<>
@
@ true, false
@ bool-only, bools-only
@ booleans, boolean-only, booleans-only
@ data type



# Byte

<cb>= b'<v>c<>'<>

<cb>= 0x<v>FF<>_u8<>

<cb>let <v>byte_1<>: u8 = b'<v>c<>';<>

Returns:

<cb>u8<>


Creates a byte value.
Stored as type <c>u8<>.


Example:

From Byte Literal:

<cb>let <v>byte_1<> = b'<v>x<>';

println!("{}", <v>byte_1<>);
println!("{}", <v>byte_1<> as char);

<#>// Prints:
//
//    120
//    x<><>

From Hex Literal:

<cb>let <v>byte_1<> = 0x<v>78<>_u8;

println!("{}", <v>byte_1<>);
println!("{}", <v>byte_1<> as char);

<#>// Prints:
//
//    120
//    x<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.u8.html">u8<>
@
@ u8, b''
@ bytes, byte-only, bytes-only
@ data type


# Byte - Operations
@
@ u8, b''
@ bytes, byte-only, bytes-only
@ data type



### Byte - To Character

<cb>= <v>byte_1<> as char<>

<cb>let <v>char_1<>: char = <v>byte_1<> as char<>


Coverts a byte to a character.


Example:

<cb>let <v>byte_1<> = b'z';

let <v>char_1<> = <v>byte_1<> as char;

println!("{}", <v>char_1<>);

<#>// Prints: "z"<><>
@
@ convert, converting, conversion, from, as, cast, char



# Character

<cb>= '<v>c<>'<>

<cb>let <v>char_1<>: char = '<v>c<>';<>

Type:

<cb>char<>

Size: 4 Bytes


Represents a unicode scalar value.


Examples:

From Literal:

<cb>let <v>char_1<> = '*';

println!("{}", <v>char_1<>);

<#>// Prints: "*"<><>

With Type Declaration:

<cb>let <v>char_1<>: char = '*';

println!("{}", <v>char_1<>);

<#>// Prints: "*"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.char.html">char<>
@
@ char, char-only, chars, chars-only
@ character-only, characters-only



# Floats
@
@ float-only, floats-only


## Float - 32-Bit, Single Precision

<cb>= <v>number<>_f32<>

<cb>let <v>float_1<>: f32 = <v>number<>;<>


Type:

<cb>f32<>


Float, 32-Bit, Single Precision


Size:	4 Bytes (32 bits)
Range:	-3.40282347 x 10<super>38<> ... 3.40282347 x 10<super>38<>


Examples:

With Literal:

<cb>let <v>float_1<> = <v>11.23<>_f32;

println!("{}", <v>float_1<>);

<#>// Prints: "11.23"<><>

With Type Declaration:

<cb>let <v>float_1<>: f32 = <v>11.23<>;

println!("{}", <v>float_1<>);

<#>// Prints: "11.23"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.f32.html">f32<>
@
@ f32, f32-only, f32s-only
@ data type




## Float - 64-Bit, Double Precision

<cb>= <v>number<>_f64<>

<cb>let <v>float_1<>: f64 = <v>number<>;<>


Type:

<cb>f64<>


Float, 64-Bit, Double Precision


Size:	8 Bytes (64 bits)
Range:	-1.7976931348623157 x 10<super>308<> ... 1.7976931348623157 x 10<super>308<>


Examples:

With Type Literals:

<cb>let <v>float_1<> = <v>11.23<>_f64;

println!("{}", <v>float_1<>);

<#>// Prints: "11.23"<><>

With Type Declaration:

<cb>let <v>float_1<>: f64 = <v>11.23<>;

println!("{}", <v>float_1<>);

<#>// Prints: "11.23"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.f64.html">f64<>
@
@ f64, f64-only, f64s-only
@ floats, float-only, floats-only
@ data type



# Float - Operations
@
@ f32, f64


### Float - Power

<cb>= <v>float_1<>.powf(<v>float_power<>)<>

<cb>= <v>float_type<>::powf(<v>float_value<>, <v>float_power<>)<>

Returns: Float


Returns the power of an floatwhen the power is a float.


Examples:

<cb>let <v>value<>: f32 = 4.0;
let <v>square<> = <v>value<>.powf(<v>2.0<>);

println!("{} squared is {}.", <v>value<>, <v>square<>);

<#>// Prints "4 squared is 16."<><>

<cb>let <v>value<>: f32 = 4.0;
let <v>square<> = f32::powf(<v>value<>, <v>2.0<>);

println!("{} squared is {}.", <v>value<>, <v>square<>);

<#>// Prints "4 squared is 16."<><>
@
@ .powf(), square



### Float - Power (Integer Power)

<cb>= <v>float_1<>.powi(<v>int_power<>)<>

<cb>= <v>float_type<>::powi(<v>float_value<>, <v>int_power<>)<>

Returns: Float


Returns the power of an float when the power is an integer.


Examples:

<cb>let <v>value<>: f32 = 4.0;
let <v>square<> = <v>value<>.powi(<v>2<>);

println!("{} squared is {}.", <v>value<>, <v>square<>);

<#>// Prints "4 squared is 16."<><>

<cb>let <v>value<>: f32 = 4.0;
let <v>square<> = f32::powi(<v>value<>, <v>2<>);

println!("{} squared is {}.", <v>value<>, <v>square<>);

<#>// Prints "4 squared is 16."<><>
@
@ .powi(), square



### Float - To Radians

<cb>= <v>float_1<>.to_radians();
@
@ convert, conversion



## Float - Conversions
@
@ from, convert, conversion, converting
@ from-float, float-to, float-into, into


### Float - To String

<cb>= <v>float_1<>.to_string()<>
@
@ .to_string(), float.to_string()



# Integer
@
@ int-only, integer-only, integers-only
@ from-integer, integer-to


## Integer - 8-Bit, Signed

<cb>= <v>number<>_i8<>

<cb>let <v>int_1<>: i8 = <v>number<>;<>

Type:

<cb>i8<>


Integer, 8-bit Signed


Size:	1 Byte (8 bits)
Range:	-128 ... 127


Examples:

With Literal:

<cb>let <v>int_1<> = <v>42<>_i8;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>

With Type Declaration:

<cb>let <v>int_1<>: i8 = <v>42<>;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.i8.html">i8<>
@
@ i8, i8-only, i8s-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ 127, -128



## Integer - 8-Bit, Unsigned

<cb>= <v>number<>_u8<>

<cb>let <v>int_1<>: u8 = <v>number<>;<>

Type:

<cb>u8<>


Integer, 8-bit Unsigned


Size:	1 Byte (8 bits)
Range:	0 ... 255


Examples:

With Literal:

<cb>let <v>int_1<> = <v>42<>_u8;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>

With Type Declaration:

<cb>let <v>int_1<>: u8 = <v>42<>;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.u8.html">u8<>
@
@ u8, u8-only, u8s-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type, 255



## Integer - 8-Bit, Unsigned - Conversion
@
@ u8, u8-only
@ u8s, u8s-only, byte
@ data type
@ from, convert, conversion, converting
@ from-integer, integer-to


### Integer - 8-Bit, Unsigned - To Character

<cb>= <v>u8_1<> as char<>

<cb>let <v>char_1<>: char = <v>u8_1<> as char<>


Coverts a u8 integer to a character.


Example:

<cb>let <v>u8_1<> = <v>42<>_u8;

let <v>char_1<> = <v>u8_1<> as char;

println!("{}", <v>char_1<>);

<#>// Prints: "*"<><>



### Integer - Bytes - To String

<cb>= String::from_utf8(<v>bytes<>)

= String::from_utf8(<v>u8_vec<>)<>

Returns:

<cb>Result\<String, FromUtf8Error><>


Coverts a u8 integer to a character.


Example:

<cb>let <v>bytes<>: Vec\<u8> = vec![84, 101, 120, 116, 33];

let <v>text<>: String = String::from_utf8(<v>bytes<>).unwrap();

println!("{}", <v>text<>);

<#>// Prints: "text!"<><>


Rust Docs: <l https://doc.rust-lang.org/stable/std/index.html>std<>::<l https://doc.rust-lang.org/stable/std/string/index.html>string<>::<l https://doc.rust-lang.org/stable/std/string/struct.String.html>String<>.<l https://doc.rust-lang.org/stable/std/string/struct.String.html#method.from_utf8>from_utf8<>
@
@ bytes



## Integer - 16-Bit, Signed

<cb>= <v>number<>_i16<>

<cb>let <v>int_1<>: i16 = <v>number<>;<>

Type:

<cb>i16<>


Integer, 16-bit Signed


Size:	2 Byte (16 bits)
Range:	-32,768 ... 32767


Examples:

With Literal:

<cb>let <v>int_1<> = <v>42<>_i16;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>

With Type Declaration:

<cb>let <v>int_1<>: i16 = <v>42<>;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.i16.html">i16<>
@
@ i16, i16-only, i16s-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type, -32768, 



## Integer - 16-Bit, Unsigned

<cb>= <v>number<>_u16<>

<cb>let <v>int_1<>: u16 = <v>number<>;<>

Type:

<cb>u16<>


Integer, 16-bit Unsigned


Size:	2 Bytes (16 bits)
Range:	0 ... 65,535


Examples:

With Literal:

<cb>let <v>int_1<> = <v>42<>_u16;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>

With Type Declaration:

<cb>let <v>int_1<>: u16 = <v>42<>;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.u16.html">u16<>
@
@ u16, u16-only, u16s-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type, 65535



## Integer - 32-Bit, Signed (Default) (i32)

<cb>= <v>number<>_i32<>

<cb>let <v>int_1<>: i32 = <v>number<>;<>

Type:

<cb>i32<>


Integer, 32-bit Signed


Size:	4 Bytes (32 bits)
Range:	-2,147,483,648 ... 2,147,483,647


Examples:

With Literal:

<cb>let <v>int_1<> = <v>42<>_i32;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>

With Type Declaration:

<cb>let <v>int_1<>: i32 = <v>42<>;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.i32.html">i32<>
@
@ i32, i32-only, i32s-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type, -2147483648, 2147483647



## Integer - 32-Bit, Unsigned (u32)

<cb>= <v>number<>_u32<>

<cb>let <v>int_1<>: u32 = <v>number<>;<>

Type:

<cb>u32<>


Integer, 32-bit Unsigned


Size:	4 Bytes (32 bits)
Range:	0 ... 4,294,967,295


Examples:

With Literal:

<cb>let <v>int_1<> = <v>42<>_u32;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>

With Type Declaration:

<cb>let <v>int_1<>: u32 = <v>42<>;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.u32.html">u32<>
@
@ u32, u32-only, u32s-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type, 4294967295



## Integer - 64-Bit, Signed

<cb>= <v>number<>_i64<>

<cb>let <v>int_1<>: i64 = <v>number<>;<>

Type:

<cb>i64<>


Integer, 64-bit Signed


Size:	8 Bytes (64 bits)
Range:	-9,223,372,036,854,775,808 ... 9,223,372,036,854,775,807


Examples:

With Literal:

<cb>let <v>int_1<> = <v>42<>_i64;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>

With Type Declaration:

<cb>let <v>int_1<>: i64 = <v>42<>;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.i64.html">i64<>
@
@ i64, i64-only, i64s-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type, -9223372036854775808, 9223372036854775807



## Integer - 64-Bit, Unsigned

<cb>= <v>number<>_u64<>

<cb>let <v>int_1<>: u64 = <v>number<>;<>

Type:

<cb>u64<>


Integer, 64-bit Unsigned.


Size:	4 Bytes (32 bits)
Range:	0 ... 18,446,744,073,709,551,615


Examples:

With Literal:

<cb>let <v>int_1<> = <v>42<>_u64;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>

With Type Declaration:

<cb>let <v>int_1<>: u64 = <v>42<>;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.u64.html">u64<>
@
@ u64, u64-only, u64s-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type, 18446744073709551615



## Integer - 128-Bit, Signed

<cb>= <v>number<>_i128<>

<cb>let <v>int_1<>: i128 = <v>number<>;<>

Type:

<cb>i128<>


Integer, 128-bit Signed


Size:	16 Bytes (128 bits)
Range:	-170,141,183,460,469,231,731,687,303,715,884,105,728 ... 170,141,183,460,469,231,731,687,303,715,884,105,727


Examples:

With Literal:

<cb>let <v>int_1<> = <v>42<>_i128;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>

With Type Declaration:

<cb>let <v>int_1<>: i128 = <v>42<>;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.i128.html">i128<>
@
@ i128, i128-only, i128s-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type, -170141183460469231731687303715884105728, 170141183460469231731687303715884105727



## Integer - 128-Bit, Unsigned

<cb>= <v>number<>_u128<>

<cb>let <v>int_1<>: u128 = <v>number<>;<>

Type:

<cb>u128<>


Integer, 128-bit Unsigned


Size:	16 Bytes (128 bits)
Range:	0 ... 340,282,366,920,938,463,463,374,607,431,768,211,455


Examples:

With Literal:

<cb>let <v>int_1<> = <v>42<>_u128;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>

With Type Declaration:

<cb>let <v>int_1<>: u128 = <v>42<>;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.u128.html">u128<>
@
@ u128, u128-only, u128s-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type, 340282366920938463463374607431768211455



## Integer - Pointer Size, Signed (isize)

<cb>= <v>number<>_isize<>

<cb>let <v>int_1<>: isize = <v>number<>;<>

Type:

<cb>isize<>


Integer, Pointer Sized, Signed
The size is the number of bytes required to hold a pointer.


32 Bit OS: 4 Bytes
64 Bit OS: 8 Bytes


Examples:

With Literal:

<cb>let <v>int_1<> = <v>42<>_isize;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>

With Type Declaration:

<cb>let <v>int_1<>: isize = <v>42<>;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.isize.html">isize<>
@
@ isize, isize-only, isizes-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type, 32 bit, 64 bit



## Integer - Pointer Size, Unsigned (usize)

<cb>= <v>number<>_usize<>

<cb>let <v>int_1<>: usize = <v>number<>;<>

Type:

<cb>usize<>


Integer, Pointer Sized, Unsigned
The size is the number of bytes required to hold a pointer.


32 Bit OS: 4 Bytes
64 Bit OS: 8 Bytes


Examples:

With Literal:

<cb>let <v>int_1<> = <v>42<>_usize;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>

With Type Declaration:

<cb>let <v>int_1<>: usize = <v>42<>;

println!("{}", <v>int_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/primitive.usize.html">usize<>
@
@ usize, usize-only, usizes-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type, 32 bit, 64 bit



## Integer - Operations
@
@ i8, i8-only, i8s-only
@ i16, i16-only, i16s-only
@ i32, i32-only, i32s-only
@ i64, i64-only, i64s-only
@ i128, i128-only, i128s-only
@ isize, isize-only, isizes-only
@ u8, u8-only, u8s-only
@ u16, u16-only, u16s-only
@ u32, u32-only, u32s-only
@ u64, u64-only, u64s-only
@ u128, u128-only, u128s-only
@ usize, usize-only, usizes-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type


### Integer - Power

<cb>= <v>int_1<>.pow(<v>power<>)<>

<cb>= <v>int_type<>::pow(<v>value<>, <v>power<>)<>


Returns: Integer


Returns the power of an integer.


Examples:

<cb>let <v>value<>: i32 = 4;
let <v>square<> = <v>value<>.pow(<v>2<>);

println!("{} squared is {}.", <v>value<>, <v>square<>);

<#>// Prints "4 squared is 16."<><>

<cb>let <v>value<>: i32 = 4;
let <v>square<> = i32::pow(<v>value<>, <v>2<>);

println!("{} squared is {}.", <v>value<>, <v>square<>);

<#>// Prints "4 squared is 16."<><>
@
@ .pow(), ::pow(), pow(), square



## Integer - Conversions
@
@ i8, i8-only, i8s-only
@ i16, i16-only, i16s-only
@ i32, i32-only, i32s-only
@ i64, i64-only, i64s-only
@ i128, i128-only, i128s-only
@ isize, isize-only, isizes-only
@ u8, u8-only, u8s-only
@ u16, u16-only, u16s-only
@ u32, u32-only, u32s-only
@ u64, u64-only, u64s-only
@ u128, u128-only, u128s-only
@ usize, usize-only, usizes-only
@ ints, int-only, ints-only
@ integers, integer-only, integers-only
@ data type, bytes
@
@ from, convert, conversion, converting
@ from-integer, integer-to, integer-into, int-to, int-into, into



### Integer - To String

<cb>= <v>int_1<>.to_string()<>
@
@ .to_string(), int.to_string()



# Str

<cb>= "<v>A String<>"<>

<cb>let <v>str_1<>: &str = "<v>A String<>";<>


Creates an immutable string of type <c>str<>.

<*>Is Immutable
Stored as an u8 Vector
Stores in UTF-8 Format<>

Can be stored in:

<*>Stack
Heap
Compiled Code<>


Examples:

<cb>let <v>str_1<> = "abc";

println!("{}", <v>str_1<>);

<#>// Prints: "abc"<><>

With Type Declaration:

<cb>let <v>str_1<>: &str = "abc";

println!("{}", <v>str_1<>);

<#>// Prints: "abc"<><>



Rust Docs: <l https://doc.rust-lang.org/stable/std/primitive.str.html>str<>
@
@ strs, str-only, strs-only
@ &strs, &str-only, &strs-only
@ data type, slice, string



## Str - Properties
@
@ strs, str-only, strs-only
@ data type, slice, string



### Str - Character Count

<cb>= <v>str_1<>.chars().count()<>

Returns:

<cb>usize<>


Returns the number of actual characters in the string accounting for Unicode encoding.

Takes O(N) Time due to unicode complexity.


Example:

<cb>let <v>str_1<> = "üôÇ‚≠êÔ∏è";

let <v>length<> = <v>str_1<>.len();
let <v>characters<> = <v>str_1<>.chars().count();

println!("String {}, length(bytes) = {}, characters = {}.", <v>str_1<>, <v>length<>, <v>characters<>);

<#>// Prints: "String üôÇ‚≠êÔ∏è, length(bytes) = 10, characters = 3."<><>
@
@ size, length
@ str.chars().count(), .chars().count(), .count()



### Str - Ends With?

<cb>= <v>str_1<>.ends_with(<v>str_2<>)<>

Returns:

<cb>bool<>


Returns true if the string starts with or equals another string.
@
@ ending in, is, substring
@ str.ends_with(), .ends_with()



### Str - Is Empty?

<cb>= <v>str_1<>.is_empty()<>

Returns:

<cb>bool<>


Tests if the string slice is an empty string (0 length).
@
@ str.is_empty(), .is_empty()



### Str - Length

<cb>= <v>string_1<>.len()<>

Returns:

<cb>usize<>


Returns the byte length of the string.
This is different to the number of characters (chars().count()).


Example:

<cb>let <v>str_1<> = "üôÇ‚≠êÔ∏è";

let <v>length<> = <v>str_1<>.len();
let <v>characters<> = <v>str_1<>.chars().count();

println!("String {}, length(bytes) = {}, characters = {}.", <v>str_1<>, <v>length<>, <v>characters<>);

<#>// Prints "String üôÇ‚≠êÔ∏è, length(bytes) = 10, characters = 3."<><>
@
@ count, size
@ str.len(), .len()



### Str - Starts With?

<cb>= <v>str_1<>.starts_with(<v>str_2<>)<>

Returns:

<cb>bool<>


Returns true if the string starts with or equals another string.
@
@ begins, starting in, is, substring
@ str.starts_with(), .starts_with()



### Str - Substring

<cb>= <v>str_1<>[<v>index<>..]

= <v>str_1<>[<v>start<>..<v>end_plus_1<>]
= <v>str_1<>[..<v>end_plus_1<>]

= <v>str_1<>[<v>start<>..=<v>ends<>]
= <v>str_1<>[..=<v>end<>]<>


Returns a substring form a string


Examples:

<cb>let <v>str_1<> = "<v>12345<>";

let <v>first<> = &<v>str_1<>[0..=0];                 <#>// Returns '1'<>

let <v>last<> = &<v>str_1<>[str_1.len() - 1.. str_1.len()];   <#>// Returns '5'<>

let <v>index_1<> = &<v>str_1<>[1..=1];               <#>// Returns '2'<>

let <v>index_1_to_3<> = &<v>str_1<>[1..4];           <#>// Returns '234'<>

let <v>index_1_to_end<> = &<v>str_1<>[1..];          <#>// Returns '2345'<>

let <v>start_to_index_3<> = &<v>str_1<>[..4];        <#>// Returns '1234'<><>
@
@ Partial, Slice, .substring(), []



### Str - Substring - Left

<cb>= <v>str_1<>[..<v>length_plus_1<>]<>


Example:

<cb>let <v>str_1<> = "12345";

let <v>substring<> = &<v>str_1<>[..3];

println!("{}", &<v>substring<>);

<#>// Prints: 123<><>
@
@ Start, Beginning, slice, partial, .left(), []


 
### Str - Substring - Right

<cb>= <v>str_1<>[<v>start<>..]<>


Example:

<cb>let <v>str_1<> = "12345";

let <v>substring<> = &<v>str_1<>[2..];

println!("{}", &<v>substring<>);

<#>// Prints: 345<><>
@
@ Last, End, slice, partial, .right(), []



### Str - Substring - Remove Prefix

<cb>= <v>str_1<>.strip_prefix(<v>prefix_1<>)<>

Returns:

<cb>Option\<&str><>


Removes the prefix but only if it is present.

Returns <c>None<> if no prefix found.



Example:

<cb>let <v>str_1<> = "https://speedsheet.io";

let <v>substring<> = &<v>str_1<>.strip_prefix("https://").unwrap();

println!("{}", &<v>substring<>);

<#>// Prints: speedsheet.io<><>
@
@ partial, string.strip_prefix() .strip_prefix()
@ delete, start, leading, beginning, starting, strip



### Str - Substring - Remove Suffix

<cb>= <v>str_1<>.strip_suffix(<v>prefix_1<>)<>


Removes the suffix but only if it is present.

Returns <c>None<> if no suffix found.


Example:

<cb>let <v>str_1<> = "file_name.txt";

let <v>substring<> = &<v>str_1<>.strip_suffix(".txt").unwrap();

println!("{}", &<v>substring<>);

<#>// Prints: file_name<><>
@
@ Postfix, string.strip_suffix(), .strip_suffix()
@ end, delete, ending, strip



## Str - Operations
@
@ strs, str-only, strs-only
@ data type, slice, string



### Str - Clone

<cb>= <v>str_1<>.to_string()<>

Returns:

<cb>String<>


To copy a string slice convert to a string.
@
@ copy, duplicate, clone
@ string.to_string(), .to_string()



### Str - Compare

Is Equal?:

<cb>= <v>str_1<> == <v>str_2<><>

Is Less Than?:

<cb>= <v>str_1<> \< <v>str_2<><>

Is Greater Than?:

<cb>= <v>str_1<> > <v>str_2<><>


Compare string slices using ==, !=, \<, >, \<=, >=.


Example:

<cb>let <v>a<> = "a";
let <v>b<> = "b";

if <v>a<> \< <v>b<> {
	println!("Less Than");
}
else {
	println!("Greater Than or Equal");
}<>
@
@ is less than, is greater than, is equal, or equal, not equal, equals
@ ==, !=, \<, >, \<=, >=



### Str - Concatenate

<cb>= <v>str_1<>.to_string() + <v>str_2<><>

<cb>= <v>str_1<>.to_string() + <v>str_2<>

= [<v>str_1<>, <v>str_2<>].concat()

= format!("{}{}", <v>str_1<>, <v>str_2<>)<>

Returns:

<cb>String<>


Joins 2 or more strings together.
Must start by converting the first <c>str<> into type <c>String<>.


Example:

<cb>let <v>a<> = "abc";
let <v>b<> = "def";

let <v>concatenated<> = <v>a<>.to_string() + <v>b<>;

println!("{}", <v>concatenated<>);

<#>// Prints: "abcdef"<><>
@
@ add, join, joining, concatenating, merge, +
@ str.to_owned(), .to_owned()



### Str - Repeat

<cb>= <v>str_1<>.repeat(<v>count<>)<>

Returns:

<cb>String<>


Repeats a string.


Example:

<cb>let <v>stars<>: String = "*".repeat(10);

println!("{}", <v>stars<>);

<#>// Prints: "**********"<><>
@
@ str.repeat(), .repeat()



### str - Replace

<cb>= <v>str_1<>.replace(<v>match<>, <v>replacement<>)<>

Returns:

<cb>String<>


Replaces all occurrenceses of a substring with another.

Replace is case sensitive.


Example:

<cb>let <v>str_1<> = "Replace <b>this<> and <b>this<> and <b>this<>.";

let <v>replaced<> = <v>str_1<>.replace("this", "that");

println!("{}", <v>replaced<>);

<#>// Prints: Replace <b>that<> and <b>that<> and <b>that<>.<><>
@
@ Update, Modify, Change, substitute, all occurences, matches
@ str.replace(), .replace()



### str - Replace First Occurence

<cb>= <v>str_1<>.replacen(<v>match<>, <v>replacement<>, 1)<>

Returns:

<cb>String<>


Replaces the first occurrencese only of a substring with another.

Replace is case sensitive.


Example:

<cb>let <v>str_1<> = "Replace <b>this<> but not this or this.";

let <v>replaced<> = <v>str_1<>.replacen("this", "that", 1);

println!("{}", <v>replaced<>);

<#>// Prints: Replace <b>that<> but not this or this.<><>
@
@ Update, Modify, Change, substitute, 1st occurence only, match, 1st
@ str.replacen(), .replacen()



### Str - Split

<cb>= <v>str_1<>.split(<v>split_string<>)<>

Usage:

<cb>let <v>strings<>: Vec\<&str> = <v>str_1<>.split(<v>split_string<>).collect()<>

Returns:

<cb>Split<>


Returns a list of strings split on the split string. 


Example:

<cb>let <v>str_1<> = "one\\ntwo\\nthree\\n";

let <v>lines<>: Vec\<&str> = <v>str_1<>.split("\\n").collect();

for <v>line<> in <v>lines<>.iter() {
	println!("'{}'", <v>line<>);
}

<#>// Prints:
//
//    'one'
//    'two'
//    'three'
//    ''<><>
@
@ str.split(), .split()



### Str - Split on Newline

<cb>= <v>str_1<>.lines()<>

Usage:

<cb>let <v>strings<>: Vec\<&str> = <v>str_1<>.lines().collect()<>

Returns:

<cb>Split<>


Returns a list of lines.

Empty lines are not returned.
Splits on newline (\\n) and newline + carriage return (\\n\\r).


Example:

<cb>let <v>str_1<> = "one\\ntwo\\nthree\\n";

let <v>lines<>: Vec\<&str> = <v>str_1<>.lines().collect();

for <v>line<> in <v>lines<>.iter() {
	println!("'{}'", <v>line<>);
}

<#>// Prints:
//
//    'one'
//    'two'
//    'three'<><>
@
@ by line break
@ str.lines(), .lines()



### Str - Split on White Space

<cb>= <v>str_1<>.split_whitespace()<>

Usage:

<cb>let <v>strings<>: Vec\<&str> = <v>str_1<>.split_whitespace().collect()<>

Returns:

<cb>Split<>


Returns a list of strings split on Unicode white space characters.

Empty strings are not returned.


Example:

<cb>let <v>str_1<> = "one two \\t\\n three \\n";

let <v>lines<>: Vec\<&str> = <v>str_1<>.split_whitespace().collect();

for <v>line<> in <v>lines<>.iter() {
	println!("'{}'", <v>line<>);
}

<#>// Prints:
//
//    'one'
//    'two'
//    'three'<><>
@
@ by whitespaces
@ str.split_whitespace(), .split_whitespace()



### Str - Trim

<cb>= <v>str_1<>.trim()<>

Returns:

<cb>&str<>


Trims leadind and trailing whitespaces from the string.
@
@ strip, remove, delete, whitespaces, white spaces
@ str.trim(), .trim()



### Str - Trim End

<cb>= <v>str_1<>.trim_end()<>

Returns:

<cb>&str<>


Trims trailing whitespaces from the string.
@
@ strip, remove, delete, whitespaces, white spaces, trailing, ending, right
@ str.trim_end(), .trim_end()



### Str - Trim Start

<cb>= <v>str_1<>.trim_start()<>

Returns:

<cb>&str<>


Trims leadind whitespaces from the string.
@
@ strip, remove, delete, whitespaces, white spaces, starting, left
@ str.trim_start(), .trim_start()



## Str - Conversions
@
@ from, convert, conversion, converting
@ from-str, str-to, str-into, into


### Str - To Bytes

<cb> <v>str_1<>.as_bytes()<>

Returns:

<cb>&[u8]<>


Returns a reference to the array of bytes in the string slice.
@
@ str.as_bytes(), .as_bytes(), get



### Str - To Chars

<cb> <v>str_1<>.chars()<>

Returns:

<cb>core::str::iter::Chars<>


Returns an iterator to the characters in the string slice.
@
@ str.chars(), .chars(), get



### Str - To Integer

<cb>= <v>str_1<>.parse()<><>

Returns:

<cb>Result\<<v>T<>, ParseIntError><>


Converts a string slice to an int.

Use turbofish (::\<>) to define returned type if needed (<c>parse::\<i32>()<>).
@
@ str.parse(), .parse()
@ signed, unsigned
@ i8, i16, i32, i64
@ u8, u16, u32, u64



### Str - To Lower Case

<cb>= <v>str_1<>.to_lowercase()<>

Returns:

<cb>String<>


Converts a string to lower case.
@
@ str.lowercase(), .lowercase(), lowercase



### Str - To Upper Case

<cb>= <v>str_1<>.to_uppercase()<>

Returns:

<cb>String<>


Converts a string to upper case.
@
@ str.uppercase(), .uppercase(), uppercase



### Str - To String

<cb>= <v>str_1<>.to_string()<>

<cb>= <v>str_1<>.to_string()
= <v>str_1<>.to_owned()
= <v>str_1<>.into()
= String::from(<v>str_1<>)<>

Returns:

<cb>String<>


Converts an <c>str<> to a <c>String<>.


Example:

<cb>let <v>str_1<>: &str = "abc";

let <v>string_1<>: String = <v>str_1<>.to_string();

println!("{}", <v>string_1<>);

<#>// Prints: "abc"<><>

Every Way:

<cb>let <v>str_1<> = "abc";

let <v>string_1<> = <v>str_1<>.to_string();
let <v>string_2<> = <v>str_1<>.to_owned();
let <v>string_3<> = String::from(<v>str_1<>);
let <v>string_4<>: String = <v>str_1<>.into();

println!("{}", <v>string_1<>);
println!("{}", <v>string_2<>);
println!("{}", <v>string_3<>);
println!("{}", <v>string_4<>);

<#>// Prints:
//
// "abc"
// "abc"
// "abc"
// "abc"<><>
@
@ get
@ str.to_string(), .to_string()
@ str.as_string(), .as_string()
@ str.to_owned(), .to_owned()
@ str.into(), .into()
@ String::from(), from()



# String

Stored a dynamic string on the heap.

<*>Is Mutable
Stored as an u8 Vector
Stores in UTF-8 Format
Is Stored on the Heap<>


Rust Doc: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/string/index.html">string<>::<l "https://doc.rust-lang.org/stable/std/string/struct.String.html">String<>
@
@ strings, string-only, strings-only


## String - Create
@
@ new, instantiate



### String - Create Empty String

<cb>= String::new()<>


Creates an empty string.


Rust Docs: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/string/index.html">string<>::<l "https://doc.rust-lang.org/stable/std/string/struct.String.html">String<>::<l "https://doc.rust-lang.org/stable/std/string/struct.String.html#method.new">new<>
@
@ String::new(), new()




### String - Create With Value

<cb>= "<v>a string<>".to_string()<>

<cb>= String::from("<v>a string<>")<>

<cb>let <v>string_1<>: String = String::from("<v>a string<>");<>

Type:

<cb>String<>


Creates a string with an initial value
@
@ initial value
@ string.to_string(), "".to_string(), .to_string(), string::from(), ::from()



### String - Create With Capacity

<cb>= String::with_capacity(<v>size<>);<>


Creates an empty string with a capacity of the given size in bytes.

Use this if you know what size the string needs to be or you want to avoid reallocating memory as the string grows.

Bytes are not equivalent to characters. Characters are UTF8 encoded and may require up to 4 bytes per character.
<c>size<> is type <c>usize<>.


Rust Docs: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/string/index.html">string<>::<l "https://doc.rust-lang.org/stable/std/string/struct.String.html">String<>::<l "https://doc.rust-lang.org/stable/std/string/struct.String.html#method.with_capacity">with_capacity<>
@
@ string::with_capacity(), with_capacity()



## String - Properties


### String - Character Count

<cb>= <v>string_1<>.chars().count()<>


Returns the number of actual characters in the string accounting for Unicode encoding.

Takes O(N) Time due to unicode complexity.


Example:

<cb>let <v>string_1<> = "üôÇ‚≠êÔ∏è".to_string();

let <v>length<> = <v>string_1<>.len();
let <v>characters<> = <v>string_1<>.chars().count();

println!("String {}, length(bytes) = {}, characters = {}.", <v>string_1<>, <v>length<>, <v>characters<>);

<#>// Prints: "String üôÇ‚≠êÔ∏è, length(bytes) = 10, characters = 3."<><>
@
@ length, size
@ string.chars().count(), .chars().count(), .count()



### String - Get Capacity

<cb>= <v>string_1<>.capacity()<>

Returns:

<cb>usize<>


Returns the capacity of the string in bytes.
@
@ string.capacity(), .capacity()



### String - Get Character

<cb>= <v>string_1<>.chars().nth(<v>index<>)<>

Returns:

<cb>Option\<char><>


Gets a single character from the string.
@
@ string.chars().nth(), .chars().nth(), .nth()



### String - Ends With?

<cb>= <v>string_1<>.ends_with(<v>str_2<>)<>

Returns:

<cb>bool<>


Returns true if the string starts with or equals another string.
@
@ ending in, is, substring
@ string.ends_with(), .ends_with()



### String - Is Empty

<cb>= <v>string_1<>.is_empty()<>

Returns:

<cb>bool<>


Tests if the string is an empty string (0 length).
@
@ string.is_empty(), .is_empty()



### String - Length

<cb>= <v>string_1<>.len()<>

Returns:

<cb>usize<>

Returns the length of the string in bytes
@
@ size, count
@ string.len(), .len()



### String - Starts With?

<cb>= <v>string_1<>.starts_with(<v>str_2<>)<>

Returns:

<cb>bool<>


Returns true if the string starts with or equals another string.
@
@ begins, starting in, is, substring
@ string.starts_with(), .starts_with()



### String - Substring

<cb>= <v>string_1<>[<v>index<>..]

= <v>string_1<>[<v>start<>..<v>end_plus_1<>]
= <v>string_1<>[..<v>end_plus_1<>]

= <v>string_1<>[<v>start<>..=<v>ends<>]
= <v>string_1<>[..=<v>end<>]<>


Returns a substring form a string


Examples:

<cb>let <v>string_1<> = "<v>12345<>".to_string();

let <v>first<> = &<v>string_1<>[0..=0];                 <#>// Returns '1'<>

let <v>last<> = &<v>string_1<>[string_1.len() - 1.. string_1.len()];   <#>// Returns '5'<>

let <v>index_1<> = &<v>string_1<>[1..=1];               <#>// Returns '2'<>

let <v>index_1_to_3<> = &<v>string_1<>[1..4];           <#>// Returns '234'<>

let <v>index_1_to_end<> = &<v>string_1<>[1..];          <#>// Returns '2345'<>

let <v>start_to_index_3<> = &<v>string_1<>[..4];        <#>// Returns '1234'<><>
@
@ Partial, Slice, .substring(), []



### String - Substring - Left

<cb>= <v>string_1<>[..<v>length_plus_1<>]<>


Example:

<cb>let <v>string_1<> = "12345".to_string();

let <v>substring<> = &<v>string_1<>[..3];

println!("{}", &<v>substring<>);

<#>// Prints: 123<><>
@
@ Start, Beginning, slice, partial, .left(), []


 
### String - Substring - Right

<cb>= <v>string_1<>[<v>start<>..]<>


Example:

<cb>let <v>string_1<> = "12345";

let <v>substring<> = &<v>string_1<>[2..];

println!("{}", &<v>substring<>);

<#>// Prints: 345<><>
@
@ Last, End, slice, partial, .right(), []



### String - Substring - Remove Prefix

<cb>= <v>string_1<>.strip_prefix(<v>prefix_1<>)<>

Returns:

<cb>Option\<&str><>


Removes the prefix but only if it is present.

Returns <c>None<> if no prefix found.



Example:

<cb>let <v>string_1<> = "https://speedsheet.io".to_string();

let <v>substring<> = &<v>string_1<>.strip_prefix("https://").unwrap();

println!("{}", &<v>substring<>);

<#>// Prints: speedsheet.io<><>
@
@ partial, string.strip_prefix() .strip_prefix()
@ delete, start, leading, beginning, starting, strip



### String - Substring - Remove Suffix

<cb>= <v>string_1<>.strip_suffix(<v>prefix_1<>)<>


Removes the suffix but only if it is present.

Returns <c>None<> if no suffix found.


Example:

<cb>let <v>string_1<> = "file_name.txt".to_string();

let <v>substring<> = &<v>string_1<>.strip_suffix(".txt").unwrap();

println!("{}", &<v>substring<>);

<#>// Prints: file_name<><>
@
@ Postfix, string.strip_suffix(), .strip_suffix()
@ end, delete, ending, strip



## String - Operations
@
@ strings, string-only, strings-only


### String - Append Character

<cb><v>string_1<>.push(<v>character_1<>);<>


Appends a character to the end of a string.


Examples:

<cb>let mut <v>string_1<> = "abc".to_string();

<v>string_1<>.push('d');

println!("{}", <v>string_1<>);

<#>// Prints: "abcd"<><>
@
@ add, join to, extend
@ string.push(), .push()



### String - Append Str

<cb>= <v>string_1<>.push_str(<v>str_2<>)<>

Appends a string slice to the end of a string.


Examples:

<cb>let mut <v>string_1<> = "abc".to_string();
let <v>str_2<> =  "def";

<v>string_1<>.push_str(<v>str_2<>);

println!("{}", <v>string_1<>);

<#>// Prints: "abcdef"<><>
@
@ add, join to, extend, slice, &str
@ string.push_str(), .push_str()



### String - Append String

<cb><v>string_1<>.push_str(&<v>string_2<>);<>


Appends a string onto another string.

The first string must be mutable.
The second string must be of type <c>str<>.


Examples:

<cb>let mut <v>string_1<> = "abc".to_string();
let <v>string_2<> =  "def".to_string();

<v>string_1<>.push_str(&<v>string_2<>);

println!("{}", <v>string_1<>);

<#>// Prints: "abcdef"<><>
@
@ add, join to, extend
@ string.push_str(), .push_str()



### String - Clone

<cb>= <v>string_1<>.clone()<>


Creates a copy of the string.
@
@ copy, duplicate
@ string.clone(), .clone()



### String - Compare

Is Equal?:

<cb>= <v>string_1<> == <v>string_2<><>

Is Less Than?:

<cb>= <v>string_1<> \< <v>string_2<><>

Is Greater Than?:

<cb>= <v>string_1<> > <v>string_2<><>


Compare strings using ==, !=, \<, >, \<=, >=.


Example:

<cb>let <v>a<> = "a".to_string();
let <v>b<> = "b".to_string();

if <v>a<> \< <v>b<> {
	println!("Less Than");
}
else {
	println!("Greater Than or Equal");
}<>
@
@ is less than, is greater than, is equal, or equal, not equal, equals
@ ==, !=, \<, >, \<=, >=



### String - Concatenate

<cb>= [<v>string_1<>, <v>string_2<>].concat()<>

<cb>= [<v>string_1<>, <v>string_2<>].concat()

= [<v>string_1<>, <v>string_2<>].join("")

= <v>string_1<> + <v>string_2<>.as_str()

= format!("{}{}", <v>string_1<>, <v>string_2<>)<>

Returns:

<cb>String<>


These are a number of ways to join two or more strings.


Example:

<cb>let <v>a<> = "abc".to_string();
let <v>b<> = "def".to_string();

let <v>concatenated<> = [<v>a<>, <v>b<>].concat();

println!("{}", <v>concatenated<>);

<#>// Prints: "abcdef"<><>
@
@ join to, concatenating, merge, +, .concat()



### String - Concatenate Str

<cb>= <v>string_1<> + <v>str_2<><>

Returns:

<cb>String<>


Concatenates a string and a string slice.


Example:

<cb>let <v>a<> = "abc".to_string();
let <v>b<> = "def";

let <v>concatenated<> = <v>a<> + <v>b<>;

println!("{}", <v>concatenated<>);

<#>// Prints: "abcdef"<><>
@
@ join to, concatenating, +, string slice



### String - Format

<cb>= format!("<v>{}<>", <v>string_1<>)<>

<cb>let <v>string_2<>: String = format!("<v>format<>", <v>string_1<>, <v>string_2<>, <v>...<>);<>


Formats a string.


Example:

<cb>let <v>string_1<> = "abc".to_string();

let <v>formatted<> = format!("<v>...{}...<>", <v>string_1<>);

println!("{}", <v>formatted<>);

<#>// Prints: "...abc..."<><>
@
@ format!()



### String - Join

<cb>= [<v>string_1<>, <v>string_2<>].join(<v>join_str<>)<>

<cb>let <v>string_1<> = [<v>string_1<>, <v>string_2<>, <v>...<>].join(<v>join_str<>);<>

Returns:

<cb>String<>


Joins all the strings in the array separated by <c>join_str<>.


Example:

<cb>let <v>string_1<> = "<v>1<>".to_string();
let <v>string_2<> = "<v>2<>".to_string();
let <v>string_3<> = "<v>3<>".to_string();

let <v>joined<> = [<v>string_1<>, <v>string_2<>, <v>string_3<>].join(", ");

println!("{}", <v>joined<>);

<#>// Prints: "1, 2, 3"<><>
@
@ .join(), merge



### String - Join Vec

<cb>= <v>vec_of_strings<>.join(<v>join_str<>)<>

<cb>let <v>string_1<> = [<v>string_1<>, <v>string_2<>, <v>...<>].join(<v>join_str<>);<>

Returns:

<cb>String<>


Joins all the strings in the array separated by <c>join_str<>.


Example:

<cb>let <v>strings<> = vec![
	"1".to_string(), 
	"2".to_string(), 
	"3".to_string()
];

let <v>joined<> = <v>strings<>.join(", ");

println!("{}", <v>joined<>);

<#>// Prints: 1, 2, 3<><>
@
@ .join(), merge, vector



### String - Pop Last Character

<cb>= <v>string_1<>.pop()<>


Removes the last character from a string.
@
@ remove, delete, ending



### String - Replace

<cb>= <v>string_1<>.replace(<v>match<>, <v>replacement<>)<>

Returns:

<cb>String<>


Replaces all occurrenceses of a substring with another.

Replace is case sensitive.


Example:

<cb>let <v>string_1<> = "Replace <b>this<> and <b>this<> and <b>this<>.".to_string();

let <v>replaced<> = <v>string_1<>.replace("this", "that");

println!("{}", <v>replaced<>);

<#>// Prints: Replace <b>that<> and <b>that<> and <b>that<>.<><>
@
@ Update, Modify, Change, substitute, all occurences, matches
@ string.replace(), .replace()



### String - Replace First Occurence

<cb>= <v>string_1<>.replacen(<v>match<>, <v>replacement<>, 1)<>

Returns:

<cb>String<>


Replaces the first occurrencese only of a substring with another.

Replace is case sensitive.


Example:

<cb>let <v>string_1<> = "Replace <b>this<> but not this or this.".to_string();

let <v>replaced<> = <v>string_1<>.replacen("this", "that", 1);

println!("{}", <v>replaced<>);

<#>// Prints: Replace <b>that<> but not this or this.<><>
@
@ Update, Modify, Change, substitute, 1st occurence only, match, 1st
@ string.replacen(), .replacen()



### String - Replace Character By Position

<cb><v>string_1<>.replace_range(<v>position<>..=<v>position<>, <v>replacement<>);

<v>string_1<>.replace_range(<v>position<>..<v>position_plus_one<>, <v>replacement<>);<>

Returns:

<cb>String<>


Replaces the character at the given position with the replacement string.

Updates the original string in plcae.
Can replace match with a larger string as long as the original string has capacity.


Example:

<cb>let mut <v>string_1<> = "1 <b>2<> 3".to_string();

<v>string_1<>.replace_range(2..=2, "*");

println!("{}", <v>string_1<>);

<#>// Prints: 1 <b>*<> 3<><>


Example:

<cb>let mut <v>string_1<> = "1 <b>2<> 3".to_string();

<v>string_1<>.replace_range(2..=2, "two");

println!("{}", <v>string_1<>);

<#>// Prints: 1 <b>two<> 3<><>
@
@ Update, Modify, Change, substitute, by index, one, single
@ string.replace_range(), .replace_range(), .., ..=



### String - Replace Substring By Position Range

<cb><v>string_1<>.replace_range(<v>start<>..=<v>end<>, <v>replacement<>);

<v>string_1<>.replace_range(<v>start<>..<v>end_plus_one<>, <v>replacement<>);<>

Returns:

<cb>String<>


Replaces the substring in the given position range with the replacement string.

Updates the original string in plcae.
Can replace match with a larger string as long as the original string has capacity.


Example:

<cb>let mut <v>string_1<> = "one <b>two<> three".to_string();

<v>string_1<>.replace_range(4..=6, "2");

println!("{}", <v>string_1<>);

<#>// Prints: one <b>2<> three<><>
@
@ Update, Modify, Change, substitute, by index, start, end
@ string.replace_range(), .replace_range(), .., ..=


### String - Split

<cb>= <v>string_1<>.split(<v>split_string<>)<>

Usage:

<cb>let <v>strings<>: Vec\<&str> = <v>string_1<>.split(<v>split_string<>).collect()<>

Returns:

<cb>Split<>


Returns a list of strings separated on the split string.

The split string is not returned.


Example:

<cb>let <v>string_1<> = "one\\ntwo\\nthree\\n".to_string();

let <v>lines<>: Vec\<&str> = <v>string_1<>.split("\\n").collect();

for <v>line<> in <v>lines<>.iter() {
	println!("'{}'", <v>line<>);
}

<#>// Prints:
//
//    'one'
//    'two'
//    'three'
//    ''<><>
@
@ split by
@ string.split(), .split()



### String - Split on Newline

<cb>= <v>string_1<>.lines()<>

Usage:

<cb>let <v>strings<>: Vec\<&str> = <v>string_1<>.lines().collect()<>

Returns:

<cb>Split<>


Returns a list of lines.

Empty lines are not returned.
Splits on newline (\\n) and newline + carriage return (\\n\\r).


Example:

<cb>let <v>string_1<> = "one\\ntwo\\nthree\\n".to_string();

let <v>lines<>: Vec\<&str> = <v>string_1<>.lines().collect();

for <v>line<> in <v>lines<>.iter() {
	println!("'{}'", <v>line<>);
}

<#>// Prints:
//
//    'one'
//    'two'
//    'three'<><>
@
@ by line break
@ string.lines(), .lines()



### String - Split on White Space

<cb>= <v>string_1<>.split_whitespace()<>

Usage:

<cb>let <v>strings<>: Vec\<&str> = <v>string_1<>.split_whitespace().collect()<>

Returns:

<cb>Split<>


Returns a list of strings split on Unicode white space characters.

Empty strings are not returned.


Example:

<cb>let <v>string_1<> = "one two \\t\\n three \\n".to_string();

let <v>lines<>: Vec\<&str> = <v>string_1<>.split_whitespace().collect();

for <v>line<> in <v>lines<>.iter() {
	println!("'{}'", <v>line<>);
}

<#>// Prints:
//
//    'one'
//    'two'
//    'three'<><>
@
@ by whitespaces
@ string.split_whitespace(), .split_whitespace()



### String - Trim

<cb>= <v>string_1<>.trim()<>

Returns:

<cb>&str<>


Trims leadind and trailing whitespaces from the string.
@
@ strip, remove, delete, whitespaces, white spaces
@ string.trim(), .trim()



### String - Trim End

<cb>= <v>string_1<>.trim_end()<>

Returns:

<cb>&str<>


Trims trailing whitespaces from the string.
@
@ strip, remove, delete, whitespaces, white spaces, trailing, ending, right
@ string.trim_end(), .trim_end()



### String - Trim Start

<cb>= <v>string_1<>.trim_start()<>

Returns:

<cb>&str<>


Trims leadind whitespaces from the string.
@
@ strip, remove, delete, whitespaces, white spaces, starting, left
@ string.trim_start(), .trim_start()



## String - Conversions
@
@ from, convert, conversion, converting
@ from-string, string-to, string-into, into


### String - To Bytes

<cb> <v>string_1<>.as_bytes()<>

Returns:

<cb>&[u8]<>


Returns a reference to the array of bytes in the underlying string slice.


Example:

<cb>let <v>text<> = "Text!";

let <v>bytes<>: &[u8] = <v>text<>.as_bytes();

println!("{:?}", <v>bytes<>);

<#>// Prints: [84, 101, 120, 116, 33]<><>
@
@ string.as_bytes(), .as_bytes(), get, u8



### String - To Chars

<cb>= <v>string_1<>.chars()<>

Returns:

<cb>core::str::iter::Chars<>


Returns an array of characters from a string.
@
@ string.chars(), .chars()



### String - To Integer

<cb>= <v>string_1<>.parse()<>

Returns:

<cb>Result\<<v>T<>, ParseIntError<>><>


Converts a string to an int.

Use turbofish (::\<>) to define returned type if needed (<c>parse::\<i32>()<>).
@
@ signed, unsigned
@ i8, i16, i32, i64
@ u8, u16, u32, u64



### String - To Lower Case

<cb>= <v>string_1<>.to_lowercase()<>

Returns:

<cb>String<>


Converts a string to lower case.
@
@ string.lowercase(), .lowercase(), lowercase



### String - To Upper Case

<cb>= <v>string_1<>.to_uppercase()<>

Returns:

<cb>String<>


Converts a string to upper case.
@
@ string.uppercase(), .uppercase(), uppercase



### String - To Str

<cb>= <v>string_1<>.as_str()<>

Usage:

<cb>let <v>str_2<>: &str = <v>string_1<>.as_str();<>


Extracts the <c>str<> data behind the string.


Example:

Using .as_str():

<cb>let <v>string_1<> = "abc".to_string();

let <v>str_2<> = <v>string_1<>.as_str();

println!("{}", <v>str_2<>);

<#>// Prints: "abc"<><>
@
@ string slice, get
@ deref coercion
@ string.as_str(), .as_str()
@ string.to_str(), .to_str()



### String - To Str / Dereference

<cb>= &<v>string_1<><>

Usage:

<cb>let <v>str_2<>: &str = &<v>string_1<>;<>


Dereferences the <c>str<> data from the string variable.


Example:

<cb>let <v>string_1<> = "abc".to_string();

let <v>str_2<>: &str = &<v>string_1<>;

println!("{}", <v>str_2<>);

<#>// Prints: "abc"<><>
@
@ string slice
@ deref coercion, &, dereferencing



# String Literal - To String

<cb>= "<v>string literal<>".to_string();<>

Or:

<cb>= String::from("<v>string literal<>");<>


Use .to_string() or ::from() to convert a string literal to a string.

String literals are stored as type &str and must be explicitly converted to type String.
This is because string literals are stored in code whereas strings are stored on the heap.
@
@ Convert, conversion, converting, from, slice



# str vs &str vs String

<c>str<>:

<*>The Actual String Data
Immutable u8 Array
UTF-8 Encoded
On Heap | Stack | Program Binary
Not Directly Referenceable<>


<c>&str<>:

<*>References str Data
Borrow Only
Knows Length<>

<in-2>For:

<*>Read Only Strings
Accessing <c>String<> Data<><>


<c>String<>:

<*>Mutable u8 Array
UTF-8 Encoded
Owns Data
On Heap<>

<in-2>For:

<*>Ownership
Passing
Dynamic String<><><>


<cb>                                    ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê
str  =                              ‚îÇ T ‚îÇ E ‚îÇ X ‚îÇ T ‚îÇ
									‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò

		   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê
&str  =    ‚îÇ pointer:  usize ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚ñ∂ ‚îÇ T ‚îÇ E ‚îÇ X ‚îÇ T ‚îÇ
		   ‚îÇ length:   usize   ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò
		   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 
							
		   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê
String  =  ‚îÇ pointer:  usize ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ‚ñ∂ ‚îÇ T ‚îÇ E ‚îÇ X ‚îÇ T ‚îÇ
		   ‚îÇ capacity: usize   ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò
		   ‚îÇ length:   usize   ‚îÇ
		   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò<>
@
@ &str


# References / Pointers
@
@ ref-only, reference-only, references-only
@ ptr-only, pointer-only, pointers-only


### Reference - Basics

<b>Declaration:<>

<table><col>Value<><col><v>T<><>
<col>Value, Mutable<><col>mut <v>T<><>
<col> <>
<col>Reference (Pointer)<><col>&<v>T<><>
<col>Reference (Pointer), Mutable<><col>&mut <v>T<><>
<col> <>
<col>Raw Pointer<><col>*const <v>T<><><col>Unsafe Read Access<>
<col>Raw Pointer, Mutable<><col>*mut <v>T<><>
<col> <>
<col>Heap Allocated Value<><col>Box\<<v>T<>><><col>Single Read / Write Owner<>
<col>Heap Allocated Value<><col>Rc\<<v>T<>><><col>Single Owner / Multiple Readers<>
<col>Heap Allocated Value<><col>Arc\<<v>T<>><><col>Single Owner / Mulitple Readers / Thread Safe<><>


<b>Assignment:<>

<table><col>Value<><col>= <v>var_1<><>
<col>Borrow (Reference, Pointer)<><col>= &<v>var_1<><>
<col>Borrow, mutabl (Reference, Pointer)<><col>= &mut <v>var_1<><>
<col>Dereferenced Pointer<><col>= *<v>var_1<><><>

<image "pointers.png">



### Reference - Dereference

<cb>= *<v>item1<>;<>

Access the data stored in <c>item1<>'s memory address.

<cb><v>item1<> ‚îÄ‚îÄ‚îÄ‚ñ∂ pointer ‚îÄ‚îÄ‚îÄ‚ñ∂ data
						 ‚ñ≤
						 ‚îÇ
*<v>item<> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò<>
@
@ *



### Reference - Print Memory Location

<cb>println!("{:p}", &<v>item<>);<>
@
@ {:p}, :p



### Reference - Borrow Error - Dangling Reference

<cb>let <v>outer_scope<>;

{
	let <v>inner_scope<> = 42;
	<v>outer_scope<> = &<v>inner_scope<>;
}

println!("{}", <v>outer_scope<>);<>

Here <c>outer_scope<> tries to borrow and then access a value after it goes out of scope.

Returns this error:

<cb><!>borrowed value does not live long enough<><>



# Unit

<cb>= ()<>

<cb>let <v>unit<> = ();<>


The value returned from a function where no value was explicitly returned.
@
@ ()
@ units, unit-only, units-only
@ data type



# Enum
@
@ enums, enum-only, enums-only
@ data type


## Enum - Basics

<cb>enum <v>Enum1<> {
	<v>Value1<>,
	<v>Value2<>,
	<v>Value3<>
}

let <v>value_1<> = <v>Enum1<>::<v>Value1<>;<>

Print:

<cb>println!("{}", <v>Enum1<>::<v>Value1<> as u8);<>

Match:

<cb>match <v>value_1<> {
	<v>Enum1<>:<v>Value1<> => <v>...<>,
	<v>Enum1<>:<v>Value2<> => <v>...<>,
	<v>Enum1<>:<v>Value3<> => <v>...<>
}<>

Enums With Properties:

<cb>enum <v>Enum1<> {
	<v>Value1<>(i32),
	<v>Value2<>(char),
	<v>Value3<>(String)
	<v>Value4<>{x: i32, y: i32}
}<>

<m>** you can mix and match.<>



## Enum - Create


### Enum - Define

<cb>enum <v>Enum1<> {
	<v>Item1<>,
	<v>Item2<>,
	<v>Item3<>
}<>

<cb>= <v>Enum1<>::Item1<>


Creates an enum with the defined items.

By default enum items are stored as a sequence of integers.


Example:

<cb>enum <v>Colors<> {
	<v>Red<>,
	<v>Green<>,
	<v>Blue<>
}

let <v>red<> = <v>Color<>::<v>Red<>;

println!("Red = {}", <v>Color<>::<v>Red<> as u8);
println!("Green = {}", <v>Color<>::<v>Green<> as u8);
println!("Blue = {}", <v>Color<>::<v>Blue<> as u8);

<#>// Red = 0
// Green = 1
// Blue = 2<><>



### Enum - Define With Explicit Values

<cb>enum <v>Enum1<> {
	<v>Item1<> = <v>value_1<>,
	<v>Item2<> = <v>value_2<>,
	<v>Item3<>
}<>

<cb>= <v>Enum1<>::Item1<>


Creates an enum where each item has a custom value.

Items with no explicit values will continue in assending values from the last set value.


Example:

<cb>enum <v>Color<> {
	<v>Red<> = 10,
	<v>Green<> = 20,
	<v>Blue<>
}

println!("Red = {}", <v>Color<>::<v>Red<> as u8);
println!("Green = {}", <v>Color<>::<v>Green<> as u8);
println!("Blue = {}", <v>Color<>::<v>Blue<> as u8);

<#>// Red = 10
// Green = 20
// Blue = 21<><>
@
@ internal, stored



### Enum - Define As Struct

<cb>enum <v>Enum1<> {
	<v>Item1<> {field: <v>type<>},
	<v>Item2<> {field_1: <v>type<>, field_2: <v>type<>},
	<v>Item3<> {field_1: <v>type<>, field_2: <v>type<>, <v>...<>}
}<>

<cb>= <v>Enum1<>::Item1{field: <v>value<>}<>


Creates an enum where the items have struct values.


Example:

<cb>enum <v>Color<> {
	<v>Base<> (u32),
	<v>Primary<> (u32),
	<v>Secondary<> (u32)
}

let <v>base<> = Color::Base(0xFF0000)<>
@
@ internal, stored



### Enum - Define As Tuples

<cb>enum <v>Enum1<> {
	<v>Item1<> (<v>type<>),
	<v>Item2<> (<v>type<>, <v>type<>),
	<v>Item3<> (<v>type<>, <v>type<>, <v>...<>)
}<>

<cb>= <v>Enum1<>::Item1(<v>value<>)<>


Creates an enum with items containing tuple data.


Example:

<cb>enum <v>Color<> {
	<v>Base<> (u32),
	<v>Primary<> (u32),
	<v>Secondary<> (u32)
}

let <v>base<> = Color::Base(0xFF0000)<>
@
@ internal, stored



## Enum - Properties



## Enum - Operations


### Enum - To Integer

<cb>= <v>Enum1<>.<v>Item1<> as u8<>


Cast enum items to unsigned integer.

This only works enums with no data attached to them (no tuple or struct enums).
@
@ convert, conversion



# Range
@
@ std::ops::Range
@ ranges, range-only, ranges-only
@ data type


### Integer Range

<cb>= <v>start<>..<v>end_plus_one<><>

<cb>= <v>start<>..=<v>end<><>

Usage:

<cb>use std::ops::Range;

let <v>range_1<>: Range\<i32> = <v>0<>..<v>4<>;<>

Type:

<cb>Range\<<v>type<>><>


Rust Docs: <l https://doc.rust-lang.org/std/ops/struct.Range.html>Range<>


Examples:

With <c>..<> :

<cb>use std::ops::Range;

let <v>range_1<>: Range\<i32> = <v>0<>..<v>4<>;

for <v>value<> in <v>range_1<> {
	print!("{} ", <v>value<>);
}
println!();

<#>// Prints: 0 1 2 3 <><>

With <c>..=<> :

<cb>use std::ops::Range;

let <v>range_1<>: Range\<i32> = <v>0<>..=<v>3<>;

for <v>value<> in <v>range_1<> {
	print!("{} ", <v>value<>);
}
println!();

<#>// Prints: 0 1 2 3 <><>



### Integer Range With Step

<cb>= (<v>start<>..<v>end_plus_one<>).step_by(<v>step_value<>)<>

<cb>= (<v>start<>..=<v>end<>).step_by(<v>step_value<>)<>

Usage:

<cb>use std::ops::Range;

let <v>range_1<>: Range\<i32> = (<v>0<>..=<v>10<>).step_by(<v>2<>);<>

Type:

<cb>Range\<<v>type<>><>


Rust Docs: <l https://doc.rust-lang.org/std/ops/struct.Range.html>Range<>
@
@ range.step_by(), .step_by()



### Float Range

<cb>= <v>start<>..<v>end_plus_one<><>

<cb>= <v>start<>..=<v>end<><>

Usage:

<cb>use std::ops::Range;

let <v>range_1<>: Range\<i32> = <v>0.0<>..<v>4.0<>;<>

Type:

<cb>Range\<<v>type<>><>


Creates a range for floating point values.

Rust places a restriction on floating ranges... they can NOT be iterated over.
This is due to the imprecise nature of floats.


Rust Docs: <l https://doc.rust-lang.org/std/ops/struct.Range.html>Range<>



### Range - Start

<cb>= <v>range_1<>.start<>



### Range - End

<cb>= <v>range_1<>.end<>



# Struct

A struct is an immutable custom data type that has named fields.
@
@ structs, struct-only, structs-only, structures, structure-only, structures-only
@ tuple-struct-only, tuple-structs-only
@ data type


## Struct - Basics

Struct Fields:

<cb>struct <v>Struct1<> {
   <v>field_1<>: <v>T1<>,
   <v>field_2<>: <v>T2<>,
   <v>field_3<>: <v>T3<>
}<>

Struct Functions and Methods:

<cb>impl <v>Struct1<> {

	fn new(<v>field_1<>, <v>field_2<>, <v>field_3<>) -> Self {
		<v>Struct1<> {<v>field_1<>, <v>field_2<>, <v>field_3<>}
	}

	fn <v>function_1<>(<v>param_1<>: <v>T4<>, <v>param_2<>: <v>T5<>) {
		<v>...<>
	}

	fn <v>method_1<>(&self, <v>param_1<>: <v>T<>, <v>...<>) {
		<v>...<>
	}
}<>

Call Function:

<cb><v>Struct1<>::<v>function_1<>(<v>param_1<>, <v>param_2<>);<>

Create:

<cb>let <v>value_1<> = <v>Struct1<> {
   <v>field_1<>: <v>value<>,
   <v>field_2<>: <v>value<>,
   <v>field_3<>: <v>value<>
};

let <v>value_2<> = <v>Struct1<>::new(<v>field_1<>, <v>field_2<>, <v>field_3<>);<>

Access:

<cb>let <v>field_1<> = <v>value_1<>.<v>field_1<>;

<v>value_1<>.method_1(<v>param_1<>, <v>...<>);<>
@
@ struct-only, structs-only, structure-only, structures-only



## Struct - Define


### Struct - Define

<cb>struct <v>Struct1<> {
   <v>field_1<>: <v>type<>,
   <v>field_2<>: <v>type<>,
   <v>field_3<>: <v>type<>
}<>


Defines a structure type.

Note:
No semicolon (<c>;<>) is required at the end of the definition.


Example:

<cb>struct <v>Point<> {
	<v>x<>: i32,
	<v>y<>: i32
}

let <v>point_1<> = <v>Point<> {
	x: 10,
	y: 20
};

println!("Point 1: {}, {}", <v>point_1<>.<v>x<>, <v>point_1<>.<v>y<>);

<#>// Prints: "Point 1: 10, 20"<><>



### Struct - Define Constructor

<cb>impl <v>Struct1<> {
	fn new() -> Self {
		<v>...<>
	}
}<>


Implement a new() function.

Rust does not support an intrinsic constructor function by default.
The idiomatic way to implement a constructor is to implement a <c>new<> function.


Example:

<cb>struct <v>Point<> {
	<v>x<>: i32,
	<v>y<>: i32
}

impl <v>Point<> {
	fn new(<v>x<>: i32, <v>y<>: i32) -> Self {
		<v>Point<> {<v>x<>, <v>y<>}
	}
}

let <v>point_1<> = <v>Point<>::new(10, 20);

println!("Point 1: {}, {}", <v>point_1<>.<v>x<>, <v>point_1<>.<v>y<>);

<#>// Prints: "Point 1: 10, 20"<><>
@
@ ::new(), new()



### Struct - Create

<cb>= <v>Struct1<> {
   <v>field_1<>: <v>value<>,
   <v>field_2<>: <v>value<>,
   <v>field_3<>: <v>value<>
}<>


Creates an instance of the struct.

Note the syntax requires {} around the fields and : between field names and values.


Example:

<cb>struct <v>Point<> {
	<v>x<>: i32,
	<v>y<>: i32
}

let <v>point_1<> = <v>Point<> {
	x: 10,
	y: 20
};

println!("Point 1: {}, {}", <v>point_1<>.<v>x<>, <v>point_1<>.<v>y<>);

<#>// Prints: "Point 1: 10, 20"<><>



### Struct - Create, Matching Names

<cb>= <v>Struct1<> {
   <v>field_1<>,
   <v>field_2<>,
   <v>field_3<>
}<>


Defines a structure type.

When the field name and variable name are the same, use this syntax (<v>field_name<>) over the longer form (<v>field_name<>: <v>variable_name<>).


Example:

<cb>struct <v>Point<> {
	<v>x<>: i32,
	<v>y<>: i32
}

let <v>x<> = 10;
let <v>y<> = 20;

let <v>point_1<> = <v>Point<> { <v>x<>, <v>y<> };

println!("Point 1: {}, {}", <v>point_1<>.<v>x<>, <v>point_1<>.<v>y<>);

<#>// Prints: "Point 1: 10, 20"<><>
@
@ shorthand


## Struct - Properties


### Struct - Get Field Value

<cb>= <v>struct_1<>.<v>field_1<><>

<cb>let <v>field_1<> = <v>struct_1<>.<v>field_1<>;<>


Returns the value of the given field.



## Struct - Operations


### Struct - Assign

<cb>let <v>struct_1<> = <v>Strut1<> {
   <v>field_1<>: <v>value<>,
   <v>field_2<>: <v>value<>,
   <v>field_3<>: <v>value<>,
};<>



### Struct - Copy

<cb>= <v>Struct1<> { 
	..<v>original<>
}<>


Creates a duplicate of the original structure.


Example:

<cb>struct <v>Point<> {
	<v>x<>: i32,
	<v>y<>: i32
}

let <v>point_1<> = <v>Point<> {
	x: 10,
	y: 20
};

let <v>point_2<> = Point { ..<v>point_1<> };

println!("Point 2: {}, {}", <v>point_2<>.<v>x<>, <v>point_2<>.<v>y<>);

<#>// Prints: "Point 2: 10, 20"<><>
@
@ ..
@ clone, duplicate



### Struct - Copy With Changes

<cb>= <v>Struct1<> {
	<v>field<>: <v>value<>, 
	..<v>original<>,
}<>


Creates a copy of the original but updates the fields with different values.

The field updatse must come first.


Example:

<cb>struct <v>Point<> {
	<v>x<>: i32,
	<v>y<>: i32
}

let <v>point_1<> = <v>Point<> {
	x: 10,
	y: 20
};

let <v>point_2<> = Point {
	<v>y<> = 200,
	..<v>point_1<>
};

println!("Point 2: {}, {}", <v>point_2<>.<v>x<>, <v>point_2<>.<v>y<>);

<#>// Prints: "Point 2: 10, 20"<><>
@
@ duplicate, update, updates, modifications, modify



# Tuple
@
@ (), data type
@ tuples, tuple-only, tuples-only=


## Tuple - Create
@
@ define, initialize, create, instantiate


### Tuple - Create - Basic

<cb>= (<v>value_1<>, <v>value_2<>, <v>value_3<>)<>

Usage:

<cb>let <v>tuple1<>:(<v>type<>, <v>type<>, <v>...<>) = (<v>value_1<>, <v>value_2<>, <v>value_3<>)<>

Immutable list of items.
Can be of mixed types.


Example:

<cb>let <v>tuple_1<> = (<v>1<>, <v>'2'<>, <v>true<>)<>



### Tuple - Create Empty Tuple

<cb>= ()<>



## Tuple Operations


### Tuple - Get Value

<cb>= <v>tuple1<>.<v>index<><>


Returns the given element from a tuple.


Example:

<cb>let <v>numbers<> = ("one", "two", "three");

let <v>second_value<> = <v>numbers<>.1;

println!("{}", <v>second_value<>);

<#>// Prints: two<><>



### Tuple - Destructure Values

<cb>let (<v>value_1<>: <v>type<>, <v>value_2<>: <v>type<>, <v>value_3<>: <v>type<>) = <v>tuple1<>;<>


Destructures the values inside a tuple into individual variables.


Example:

<cb>let <v>numbers<> = ("1", "2", "3");

let (<v>one<>, <v>two<>, <v>three<>) = <v>numbers<>;

println!("{}, {}, {}", <v>one<>, <v>two<>, <v>three<>);

<#>// Prints: 1, 2, 3<><>
@
@ get



# Tuple Struct

A tuple structure is an immutable custom data type with enumerated fields.
@
@ tuple structs
@ tuple-struct-only, tuple-structs-only, tuple-structure-only, tuple-structures-only
@ struct-only, structs-only, structure-only, structures-only
@ data type



## Tuple Struct - Basics

Define:

<cb>struct <v>Struct1<>(<v>type<>, <v>type<>, <v>type<>);<>

Create:

<cb>let <v>value_1<> = <v>Strut1<>(<v>value<>, <v>value<>, <v>value<>);<>

Access:

<cb>let <v>first_field<> = <v>value_1<>.<v>0<>;<>



## Tuple Struct - Define

<cb>struct <v>TupleStruct1<>(<v>type<>, <v>type<>, <v>type<>);<>


Defines a tuple struct.

Note:
A semicolon (<c>;<>) is required at the end of the definition.


Example:

<cb>struct <v>Point<>(<v>i32<>, <v>i32<>);

let <v>point_1<> = <v>Point<>(<v>10<>, <v>20<>);

println!("Point 1: {}, {}", <v>point_1<>.0, <v>point_1<>.1);

<#>// Prints: "Point 1: 10, 20"<><>
@
@ create, new, instantiate



## Tuple Struct - Properties


### Tuple Structure - Get Field Value

<cb>= <v>value_1<>.<v>0<>;<>

<cb>let <v>first_field<> = <v>value_1<>.<v>0<>;<>



## Tuple Struct - Operations



### Tuple Struct - Assign

<cb>let <v>value_1<> = <v>TupleStrut1<>(<v>value<>, <v>value<>, <v>value<>);<>



# Array

Type:

<cb>: [<v>Type<>; <v>size<>]<>

Immutable list of items.
All items must be of the same type.


Rust Docs: <l https://doc.rust-lang.org/std/primitive.array.html>Arrays<>
@
@ arrays, array-only, arrays-only, ;
@ data type



## Array - Define



### Array - Create - Empty

<cb>let <v>array_1<>: [<v>Type<>; <v>size<>] = [<v>empty_value<>; <v>size<>];<>


Creates an array with the given initial value.


Example:

<cb>let <v>array_1<>: [<v>i32<>; 3] = [0; 3];

println!("{:?}", &<v>array_1<>);

<#>// Prints: [0, 0, 0]<><>
@
@ new, define, instantiate, initial values
@ []



### Array - Create - With Values

<cb>= [<v>value_1<>, <v>value_2<>, <v>value_3<>]<>

<cb>let <v>array_1<>: [<v>Type<>; <v>size<>] = [<v>...<>]<>


Example:

<cb>let <v>array_1<> = [<v>1<>, <v>2<>, <v>3<>];<>

<cb>let <v>array_1<>: [<v>i32<>; <v>3<>] = [<v>1<>, <v>2<>, <v>3<>];<>
@
@ new, define, instantiate
@ []



## Array - Properties


### Array - Get

<cb>= <v>array_1<>[<v>index<>]<>


Example:

<cb>let <v>array_1<> = [<v>1<>, <v>2<>, <v>3<>];

<v>first<> = <v>array_1<>[<v>0<>];<>
@
@ item, element, value



### Array - Get First

<cb>= <v>array_1<>[0]<>


Example:

<cb>let <v>array_1<> = [<v>1<>, <v>2<>, <v>3<>];

<v>first<> = <v>array_1<>[<v>0<>];<>
@
@ item, element, value



### Array - Get Last

<cb>= <v>array_1<>[<v>array_1<>.len() - 1]<>


Example:

<cb>let <v>array_1<> = [<v>1<>, <v>2<>, <v>3<>];

let last = <v>array_1<>[<v>array_1<>.len() - 1];<>
@
@ item, element, value



### Array - Iterate

<cb>for <v>item<> in <v>array_1<> {
	<v>...<>
}<>



### Array - Length

<cb>= <v>array_1<>.len()<>

Returns:

<cb>usize<>
@
@ .len(), get
@ length, count, size



# Vec

<cb>Vec\<<v>T<>><>

Type: <c>std::vec::Vec<>


A Mutable Array of Items.

Lives in the heap.


Rust Docs: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/vec/index.html">vec<>::<l "https://doc.rust-lang.org/stable/std/vec/struct.Vec.html">Vec<>
@
@ std::vec::vec, vec::vec
@ vecs, vec-only, vecs-only
@ vectors, vector-only, vectors-only



## Vec - Create
@ new, define, instantiate


### Vec - Create

<cb>= Vec::new()<>

Full Usage:

<cb>let <v>vec_1<>: Vec\<<v>T<>> = Vec::new();<>

Type:

<cb>Vec\<<v>T<>><>

Returns:

<cb>std::vec::Vec<>


Creates a new instance of <c>vec<>.
@
@ vec::new()



### Vec - Create Using Macro

<cb>= vec![]

= vec![<v>item_1<>, <v>item_2<>, <v>...<>]<>

Usage:

<cb>let <v>vec_1<>: Vec\<<v>i32<>> = vec![];

let <v>vec_1<> = vec![<v>item_1<>, <v>item_2<>, <v>...<>];<>

Returns:

<cb>std::vec::vec<>


Creates a vec using the <c>vec!<> macro.


Example:

<cb>let <v>vec_1<> = vec!["<v>a<>", "<v>b<>", "<v>c<>"];

for <v>item<> in <v>vec_1<>.iter() {
	print!("{} ", <v>item<>);
}
println!();

<#>// Prints: "a b c "<><>
@
@ vec!, vec![]



## Vec - Properties




### Vec - Contains

<cb>= <v>vec_1<>.contains(<v>item<>);<>


Returns true if the item exists in the vec.
@
@ item, element, value



### Vec - Get

<cb>= <v>vec_1<>[<v>index<>]

= <v>vec_1<>.get(<v>index<>)<>


Returns the item at the given index.


<c><v>vec_1<>[<v>index<>]<>:

<*>Fastest method.
Panics if out-of-bounds.<>

<c><v>vec_1<>.get(<v>index<>)<>:

<*>Returns <c>Option\<<v>Type<>><>
Out-of-Bounds returns <c>None<><>
@
@ element, value, item
@ vec[], [], vec.get(), .get()



### Vec - Get First

<cb>= <v>vec_1<>[0]

= <v>vec_1<>.get(0)<>


Returns the first item in the vec.
@
@ element, value, item
@ beginning
@ vec[], [], vec.get(), .get()
@ [0], .get(0)



### Vec - Get Last

<cb>= <v>vec_1<>[<v>vec_1<>.len() - 1]

= <v>vec_1<>.get(<v>vec_1<>.len() - 1)<>


Returns the item at the given index.
@
@ element, value, item
@ end, final
@ vec[], [], vec.get(), .get()



### Vec - Get Slice

<cb>= <v>vec_1<>[<v>range<>]

= <v>vec_1<>[<v>min<>..<v>max_plus_one<>]

= <v>vec_1<>[<v>min<>..=<v>max<>]<>

Returns:

<cb>&<v>T<>[]<>


Returns a slice of the vec as an array.
@
@ subvec, sublist



### Vec - Iterator

<cb>= <v>vec_1<>.iter()<>

Returns:

<cb>core::slice::iter::Iter\<<v>type<>><>


Returns an iterator to the values in the vector.


Example:

<cb>let <v>vec_1<> = vec!["<v>a<>", "<v>b<>", "<v>c<>"];

for <v>item<> in <v>vec_1<>.iter() {
	print!("{} ", <v>item<>);
}
println!();

<#>// Prints: "a b c "<><>
@
@ vec.iter(), .iter()



### Vec - Iterator (Mutable)

<cb>= <v>vec_1<>.iter_mut()<>


Returns a mutable iterator to the values in the vector.
@
@ vec.iter_mut(), .iter_mut()



### Vec - Length

<cb>= <v>vec_1<>.len()<>

Returns:

<cb>usize<>


Returns the number of items in the vec.


Example:

<cb>let <v>vec_1<> = vec!["<v>a<>", "<v>b<>", "<v>c<>"];

println!("Size {}.", <v>vec_1<>.len());

<#>// Prints: "Size 3."<><>
@
@ count, length, size
@ vec.len(), .len()



## Vec - Operations


### Vec - Append

<cb><v>vec_1<>.push(<v>item<>)<>


Appends an item to the end of the vec.
@
@ vec.push(), .push(), push
@ add, put, extend to, value, to end
@ item, element, value



### Vec - Append Vec - Copy

<cb><v>vec_1<>.extend(<v>vec_2<>.iter().copied())<>


Copies the elements of a second vec to the end of the first.

The second vec still contains it's elements.
@
@ vec.extend, .extend()
@ add, put, extend to, second, to end, merge



### Vec - Append Vec - Move

<cb><v>vec_1<>.append(&mut <v>vec_2<>)<>


Moves the elements of a second vec to the end of the first.

The second vec will be emptied of all elements.
@
@ vec.append, .append()
@ add, put, extend to, second, to end, merge



### Vec - Clear

<cb><v>vec_1<>.clear()<>


Clears all elements from the vec.
@
@ remove all, delete all
@ vec.clear(), .clear()



### Vec - Clone

<cb>= <v>vec_1<>.clone()<>


Creates a shallow copy of the vec.
@
@ copy, duplicate
@ vec.clone(), .clone()



### Vec - Insert

<cb><v>vec_1<>.insert(<v>index<>, <v>item<>)<>


Inserts an item at the given index.
@
@ vec.insert(), .insert(), insert
@ add, put, extend to, value, to end
@ item, element, value



### Vec - Insert First

<cb><v>vec_1<>.insert(0, <v>item<>)<>


Inserts an item at the beginning of the vec.
@
@ vec.insert(), .insert(), insert
@ add, put, extend to, value, to end
@ item, element, value



### Vec - Merge

<cb>let mut <v>merged<> = <v>vec_1<>.clone();
<v>merged<>.extend(<v>vec_2<>.iter().copied());<>


Creates a new vec containing all elements from both vecs.
@
@ vecs, join, concatenate, combine, union



### Vec - Remove

<cb>= <v>vec_1<>.remove(<v>index<>)<>


Removes and returns the item at the given index.
@
@ vec.remove(), .remove(), remove
@ delete
@ item, element, value



### Vec - Remove First

<cb>= <v>vec_1<>.remove(0)<>


Removes and returns the first item in the vec.
@
@ vec.remove(), .remove(), remove
@ first, 1st, beginning
@ delete
@ item, element, value



### Vec - Remove Last

<cb>= <v>vec_1<>.pop()<>


Removes and returns the last item from the vec.
@
@ vec.remove(), .remove(), remove
@ vec.pop(), .pop()
@ end, final, ending
@ delete
@ item, element, value



### Vec - Reverse

<cb><v>vec_1<>.reverse();<>


Reverses the items in the vec.

Reverses in place.
@
@ vec.reverse(), .reverse(), reverse
@ items, elements, values



### Vec - Sort

<cb><v>vec_1<>.sort();<>


Sorts the items in the vec.

Sorts in place.
@
@ vec.sort(), .sort(), sort
@ items, elements, values



# Associated Functions and Methods

These are functions and methods accosiated with a particular data type.

Functions apply to the type (similar to class static methods).
Methods apply to an instance of a type.
@
@ associated-, assoc-, ass-, impl
@ struct-only, structs-only


## Associated Functions
@
@ associated-functions, ass-fn


### Associated Function - Define

<cb>impl <v>Type<> {
	fn <v>function1<>() -> <v>return_type<> {
		<v>...<>
	}
}<>


Defines a function associated with the given type.


Example:

<cb>struct <v>Point<> {
	<v>x<>: f32,
	<v>y<>: f32
}

impl <v>Point<> {
	fn distance_from_0_0(<v>point<>: &<v>Point<>) -> f32 {
		(<v>point<>.<v>x<>.powi(2) + <v>point<>.<v>y<>.powi(2)).powf(0.5)
	}
}

let <v>point_1<> = <v>Point<> { x: 10.0, y: 20.0};

let <v>distance<> = <v>Point<>::distance_from_0_0(&<v>point_1<>);

println!("Point Distance: {}", <v>distance<>);

<#>// Prints: "Point Distance: 22.36068"<><>


### Associated Function - Define - Return Self

<cb>impl <v>Type<> {
	fn <v>function1<>() -> Self {
		<v>...<>
	}
}<>


The <c>Self<> type defines the return type as an instance of the type itself.


Example:

<cb>struct <v>Point<> {
	<v>x<>: i32,
	<v>y<>: i32
}

impl <v>Point<> {
	fn new(<v>x<>: i32, <v>y<>: i32) -> Self {
		<v>Point<> {<v>x<>, <v>y<>}
	}
}

let <v>point_1<> = <v>Point<>::new(10, 20);

println!("Point 1: {}, {}", <v>point_1<>.<v>x<>, <v>point_1<>.<v>y<>);

<#>// Prints: "Point 1: 10, 20"<><>



### Associative Function - Call

<cb>= <v>Type<>::<v>function1<>()<>


Calls the function associated with the type.
@
@ ::


## Associated Methods

Associative methods are associative functions that apply to an instance of a type.
@
@ associated-method, ass-meth, self, &self


### Associated Method - Define

<cb>impl <v>Type<> {
	fn <v>function1<>(self) {
		<v>...<>
	}
}<>

All Variants:

<cb>impl <v>Type<> {
	fn <v>function1<>(self) { <v>...<> }
	fn <v>function2<>(&self) { <v>...<> }
	fn <v>function3<>(&mut self) { <v>...<> }
}<>


Define an associated method by including the parameter self / &self / &mut self.



### Associative Method - Call

<cb>= <v>item1<>.<v>function1<>()<>


Calls the method associated with the item.
@
@ .



# Attributes

Anything in Form:

<cb>#[<v>...<>]<>

<cb>#![<v>...<>]<>


An attribute is metadata relating to some module or item. It is used by the compiler.


Apply To Module, Item:

<cb>#[<v>...<>]<>

Apply To Entire Crate:

<cb>#![<v>...<>]<>


Rust Docs: <l https://doc.rust-lang.org/reference/attributes.html<>Attributes<>
@
@ #[, ], #[]
@ #![, ], #![]
@ attribute-only, attributes-only



### Attribute - Apply To Module Or Item

<cb>#[<v>...<>]<>


Example:

<cb>#[deprecated]
fn <v>deprecated_function<>() {
	<v>...<>
}<>



### Attribute - Apply To Entire Crate

<cb>#![<v>...<>]<>


Example:

<cb>#![allow(dead_code)]<>



### Attribute Types

4 Types:

<*>Built-in
Macro
Derive Macro Helper
Tool<>



# Attribute - Reference


### Attribute - Config / cfg

<cb>#[cfg(<v>property<> = <v>value<>)]<>
@
@ #[cfg], #[cfg()]


#### Config Property - Target Architecture

<cb>#[cfg(<v>target_arch<> = "<v>x86_64<>"")]<>

Values:

<cb>"x86"
"x86_64"
"mips"
"powerpc"
"powerpc64"
"arm"
"aarch64"<>
@
@ #[cfg(target_arch=)], target_arch



### Attribute - Deprecated

<cb>#[deprecated]<>

Marks a component as deprecated.
@
@ #[deprecated]



### Attribute - Derive Clone

<cb>#[derive(Clone)]<>

Tells the compiler to auto-generate an implementation of the Clone trait.

Example:

<cb>#[derive(Clone)]
struct <v>Point<> {
	<v>x<>: i32,
	<v>y<>: i32
}

fn main() {

	let <v>point<> = <v>Point<> {<v>x<>: 3, <v>y<>: 4};
	let <v>point_2<> = <v>point<>.clone();

	println!("Point: {},{}", &<v>point_2<>.<v>x<>, &<v>point_2<>.<v>y<>);
}

<#>// Prints: Point: 3,4<><>

Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l https://doc.rust-lang.org/std/clone/index.html>clone<>::<l https://doc.rust-lang.org/std/clone/trait.Clone.html>Clone<>
@
@ #[derive(clone)], derive, clone, (clone)
@ #[derive(copy)], derive, copy, (copy)
@ std::clone::Clone



### Attribute - Derive Debug

<cb>#[derive(Debug)]<>

Tells the compiler to auto-generate an implementation of the Debug trait.
Provides an implementation for <c>"{:?}"<> as used by <c>println!()<>, <c>format!()<>, etc..
@
@ #[derive(Debug)], derive, debug, (debug)
@ :?, {:?}



### Attribute - Derive Default

<cb>#[derive(Default)]<>

Tells the compiler to auto-generate an implementation of the Default trait.

This will create a default instance with reasonable initial values.
@
@ #[derive(default)], derive, default, (default)
@ :?, {:?}



### Attribute - Linter - Allow

<cb>[allow(<v>...<>)]<>



#### Attribute - Linter - Allow Dead Code

<cb>#![allow(dead_code)]<>
@
@ #![allow(dead_code)]



#### Attribute - Linter  - Allow Unused Imports

<cb>#[allow(unused_imports)]<>

Place right before import statement.
@
@ #[allow(unused_imports)]



#### Attribute - Linter  - Allow Unused Varibles

<cb>#[allow(unused_variables)]<>
@
@ #[allow(unused_variables)]



### Attribute - Unused Imports - Silence Warning

<cb>#[warn(unused_imports)]<>

<m>Example<>
@
@ #[warn(unused_imports)]



### Attribute - Unused Variables - Silence Warning

<cb>#[warn(unused_variables)]<>

<m>Example<>
@
@ #[warn(unused_variables)]



# Error Handling

There are 2 types of errors in Rust:

<*>Recoverable
Unrecoverable<>
@
@ Exceptions, except-only, exception-only, exceptions-only
@ Errors, error-only, error-handling-only, errors-only


## Error - Basics

Recoverable Error:

<cb>fn <v>do_something<>() -> Result\<<v>Type<>, <v>Error<>> {

	<#>// Return good result:<>
	return Ok(<v>data<>);

	<#>// Return error:<>
	return Err(<v>error<>);
}<>

Propagate Recoverable Error:

<cb>fn <v>call_do_something<>() -> Result\<<v>Type<>, <v>Error<>> {

	return <v>do_something<>()?;
}<>

Handle Recoverable Error:

<cb>match <v>result<> {
	Ok(<v>data<>) => {	<v>...<> }
	Err(<v>error<>) => { <v>...<> }
}<>


Unrecoverable Error:

<cb>panic!("<v>Error Message<>");<>



## Recoverable Error
@
@ result\<>, ok(), err()


### Recoverable Error - Define

<cb>fn <v>do_something<>() -> Result\<<v>T<>, <v>Error<>> {

	<#>// Return good result:<>
	return Ok(<v>data<>);

	<#>// Return error:<>
	return Err(<v>error<>);
}<>

Use <c>Result\<<v>T<>, <v>E<>> to return errors.

Call <c>OK() 
@
@ define, new, instantiate



### Recoverable Error - Propagate Error

<cb>fn <v>call_do_something<>() -> Result\<<v>Data<>, <v>Error<>> {

	return <v>do_something<>()?;
}<>
@
@ question mark, ? operator



### Recoverable Error - Handle Error

<cb>match <v>result<> {
	Ok(<v>data<>) => {	<v>...<> }
	Err(<v>error<>) => { <v>...<> }
}<>
@
@ match err()



### Recoverable Error - Return from Main

<cb>fn main() -> Result\<(), Box\<dyn Error + 'static>> {
	<v>...<>
}<>

Usage:

<cb>use std::error::Error;

fn main() -> Result\<(), Box\<dyn Error + 'static>> {
    <v>some_function<>()?;
    Ok(())
}<>

Returns an error from main.

The error text will be printed to the console.
@
@ std::error::Error, main()



## Unrecoverable Error


### Unrecoverable Error - Create

<cb>panic!("<v>Error Message<>");<>
@
@ define, new, instantiate
@ panic!()



### Unrecoverable Error - Show Stack Trace

Set Environment Variable:

<cb>RUST_BACKTRACE=1<>

Set <c>RUST_BACKTRACE<> to 1 to enable stack traces during panics (dev environment only).
@
@ rust_backtrace


## Standard IO Errors

Type: <c>Enum std::io::ErrorKind<>

<cb>AddrInUse
AddrNotAvailable
AlreadyExists
ArgumentListTooLong
BrokenPipe
ConnectionAborted
ConnectionRefused
ConnectionReset
CrossesDevices
Deadlock
DirectoryNotEmpty
ExecutableFileBusy
FilesystemLoop
FilesystemQuotaExceeded
FileTooLarge
HostUnreachable
Interrupted
InvalidData
InvalidFilename
InvalidInput
IsADirectory
NetworkDown
NetworkUnreachable
NotADirectory
NotConnected
NotFound
NotSeekable
OutOfMemory
PermissionDenied
ReadOnlyFilesystem
ResourceBusy
StaleNetworkFileHandle
StorageFull
TimedOut
TooManyLinks
UnexpectedEof
Unsupported
WouldBlock
WriteZero
Other<>

Docs: <l https://doc.rust-lang.org/nightly/std/io/enum.ErrorKind.html>ErrorKind<>



# Functions
@
@ fn, fns, fn-only, fns-only
@ funcs, func-only, funcs-only
@ fuctions, function-only, functions-only



## Function - Basics

Define - No Parameters:

<cb>fn <v>name<>() {
   <v>...<> 
}<>

Define - With Parameters:

<cb>fn <v>name<>(param_1: <v>type<>, param_2: <v>type<>) {
   <v>...<> 
}<>

Return Value (Explicit):

<cb>fn <v>name<>() {
   return <v>return_value<>; 
}<>

Return Value (Implicit):

<cb>fn <v>name<>() {
   <v>return_expression<>
}<>

Return Multiple Values:

<cb>fn <v>name<>() {
   return (<v>value_1<>, <v>value_2<>); <#>// Return as tuple.<>
}<>



## Function - Define

<cb>fn <v>name<>() {
	<v>...<>
}<>

<cb>fn <v>name<>(<v>param_1<>: <v>type<>, <v>param_2<>: <v>type<>) -> <v>return_type<> {
	return <v>return_value<>;
}<>


Defines a function.


Example:

<cb>fn square(<v>value<>: f64) -> f64 {
	return <v>value<>
}
@
@ definition



## Function - Arguments
@
@ parameters


### Function - Argument - Pass By Reference

<cb>fn <v>function1<>(<v>by_reference<>: &<v>type<>) {
	<v>...<>
}<>


Passes an argument to a function by reference.

Use <c>&<> in the argument type and also on the function call parameter.


Example:

<cb>fn <v>double<>(<v>value<>: &i32) -> i32 {
	<v>value<> * 2
}

let <v>value<> = 10;

println!("{} doubled = {}", <v>value<>, <v>double<>(&<v>value<>));<>
@
@ &



### Function - Argument - Pass By Value

<cb>fn <v>function1<>(<v>by_value<>: <v>type<>) {
	<v>...<>
}<>


Passes an argument to the function by value.


Example:

<cb>fn <v>double<>(<v>value<>: i32) -> i32 {
	<v>value<> * 2
}

let <v>value<> = 10;

println!("{} doubled = {}", <v>value<>, <v>double<>(<v>value<>));<>



## Function - Return


### Function - Return Value (Explicit)

<cb>return <v>return_value<>;<>

<cb>fn <v>name<>() -> <v>return_type<> {
   return <v>return_value<>;
}<>


Use the keyword <c>return<> to explicitly return a value.


Example:

<cb>fn <v>square<>(<v>x<>: i32) -> i32 {
	return <v>x<> * <v>x<>;
}

fn main() {

	let <v>value<> = <v>4<>;
	let <v>square<> = square(<v>value<>);

	println!("{} squared is {}.", <v>value<>, <v>square<>);
}<>



### Function - Return Value (Implicit)

<cb>fn <v>name<>() -> <v>return_type<> {
   <v>return_expression<>
}<>


If the last expression has no semicolon (;), it is the return value.


Example:

<cb>fn <v>square<>(<v>x<>: i32) -> i32 {
	<v>x<> * <v>x<>
}

fn main() {

	let <v>value<> = <v>4<>;
	let <v>square<> = square(<v>value<>);

	println!("{} squared is {}.", <v>value<>, <v>square<>);
}<>



### Function - Return Multiple Values

<cb>return (<v>value_1<>, <v>value_2<>, <v>value_3<>);<>

Full Form:

<cb>fn <v>name<>() -> (<v>return_type<>, <v>return_type<>, <v>return_type<>) {
   return (<v>value_1<>, <v>value_2<>, <v>...<>);
}<>

Call:

<cb>let (<v>return_1<>, <v>return_2<>, <v>...<>) = <v>name<>(<v>value<>);<>


Return multiple values in a tuple.


Example:

<cb>fn <v>double_and_triple<>(<v>x<>: i32) -> (i32, i32) {
	let <v>double<> = <v>x<> * 2;
	let <v>triple<> = <v>x<> * 3;
	return (<v>double<>, <v>triple<>);
}

fn main() {

	let <v>value<> = <v>4<>;
	let (<v>double<>, <v>triple<>) = double_and_triple(<v>value<>);

	println!("{} doubled and tripled is {}, {}.", <v>value<>, <v>double<>, <v>triple<>);
}<>



### Function - Return Nothing

<cb>fn <v>name<>() {
	<v>...<>
	<#>// Nothing returned.<>
}<>


Returns unit by default.


Example:

<cb>use std::any::type_name;

fn type_of<T>(_: T) -> &'static str {
	type_name::<T>()
}

<#>/// Returns nothing:<>
fn <v>print_square<>(<v>x<>: i32) {
	let <v>squared<> = <v>x<> * <v>x<>;
	println!("{} squared is {}.", <v>x<>, <v>squared<>);
}

fn main() {
	let <v>return_value<> = <v>print_square<>(<v>2<>);
	println!("returned value type is {}.", type_of(<v>return_value<>));
}

<#>// Prints:
//
//    2 squared is 4.
//    returned value type is ().<><>
@
@ unit, (), exit no value



### Function - Return With No Value

<cb>return;<>

Usage

<cb>fn <v>function_1<>() {
	<v>...<>
	if <v>condition<> {
		return;
	}
	<v>...<>
}<>


Returns from a function without returning a value.
@
@ unit, (), exit no value



# Function Type


### Function Type

<cb>fn(<v>type<>) -> <v>return_type<><>

<cb>let <v>function_reference<>: fn(<v>type<>) -> <v>return_type<> = <v>function_1<>;<>


Example:

<cb>fn <v>square_a_value<>(<v>value<>: i32) -> i32 {
	<v>value<> * <v>value<>
}

let <v>square<>: fn(i32) -> i32 = <v>square_a_value<>;

let <v>squared_value<> = <v>square<>(4);

println!("4 squared is {}.", <v>squared_value<>);

<#>// Prints: "4 squared is 16."<><>
@
@ fn


### Function Type - Referencing Basics

A Function:

<cb>fn <v>square<>(<v>value<>: i32) -> i32 {
	<v>value<> * <v>value<>
}<>

Create Reference:

<cb>let <v>square_2<>: fn(i32) -> i32 = <v>square<>;<>

Call:

<cb>let <v>squared_value<> = <v>square_2<>(4);<>
@
@ reference



# Closure

A closure is a function that 'closes over' the environment itwas defined in.

It has access to all the variables that are in scope.
@
@ functions, closures, anonymous, lambdas
@ closure-only, closures-only


## Closure - Create
@
@ new, define


### Closure - Create With No Arguments

<cb>= || <v>...<><>

<cb>let <v>closure_1<> = || <v>...<>;<>


Closure with 0 arguments.


Example:

<cb>let <v>closure_1<> = || println!("Closure 1 called.");

closure_1();<>
@
@ ||, zero, 0
@ parameters



### Closure - Create With Arguments

<cb>= |<v>param_1<>: <v>type<>| <v>...<><>

<cb>let <v>closure_1<> = |<v>param_1<>: <v>type<>| <v>...<>;<>


Closure with one or more arguments.


Example:

<cb>let <v>closure_1<> = |<v>param_1<>: &str| println!("Parameter 1 = {}.", <v>param_1<>);

closure_1("Value 1");<>
@
@ parameters



### Closure - Create Referencing Enclosed Variable

Example:

<cb>let <v>value<> = 42;

let <v>closure_1<> = || println!("Value 1 = {}", <v>value<>);
<v>closure_1<>();

<#>// Prints "Value 1 = 42"<><>
@
@ local scope



# Generics
@
@ generics-only, gen-only



### Generic Function
@
@ fn


#### Generic Function - Define

<cb>fn <v>function_1<> \<<v>T<>> (<v>param_1<>: <v>T<>) {
	<v>...<>
}<>

<cb>fn <v>function_1<> \<<v>T1<>, <v>T2<>, <v>T3<>> (<v>param_1<>: <v>T1<>, <v>param_2<>: <v>T2<>, <v>param_3<>: <v>T3<>) {
	<v>...<>
}<>


Allows a function to accept a data type that will be defined later by the calling program.



#### Generic Function - Bounded Type

<cb>fn <v>function_1<> \<<v>T<>: <v>Trait1<>> (<v>param_1<>: <v>T<>) {
	<v>...<>
}<>

<cb>fn <v>function_1<> \<<v>T<>: <v>Trait1<>, <v>U<>: <v>Trait2<>> (<v>param_1<>: <v>T<>) {
	<v>...<>
}<>


Defines a generic type that must implement a trait.
@
@ constraints, constrain



### Generic Struct

Generics allows a structure to contain a data type that will be defined later by the calling program.

The data type is defined at the time the structure is created.



#### Generic Struct - Basics

<cb>struct <v>Struct1<>\<<v>T<>> {
	<v>field_1<>: <v>T<>
}<>

<cb>impl \<<v>T<>> <v>Struct1<>\<<v>T<>> {

	fn <v>function1<>() -> <v>T<> { <v>...<> }

	fn <v>function2<>(<v>param1<>: <v>T<>) { <v>...<> }

	<v>...<>
}<>

<cb>let <v>item_1<>: <v>Struct1<>\<<v>Type<>> = <v>Struct1<> { <v>value<> };

let <v>value_1<>: <v>Type<> = <v>item_1<>.field_1;<>




#### Generic Structure Implemenation - Define

<cb>impl \<<v>T<>> <v>Struct1<>\<<v>T<>> {
}<>

<cb>impl \<<v>T<>> <v>Struct1<>\<<v>T<>> {

	fn <v>function1<>() -> <v>T<> { <v>...<> }

	fn <v>function2<>(<v>param1<>: <v>T<>) { <v>...<> }

	<v>...<>
}<>
@
@ create, new



#### Generic Structure Implementation - Use

<cb>let <v>item_1<>: <v>Struct1<>\<<v>ActualType<>> = <v>Struct1<> { <v>value<> };<>

<cb>= <v>item_1<>.<v>function1<>()
<v>item_1<>.<v>function2<>(<v>value<>);<>
@
@ create, new, instantiate



### Generic Trait


#### Generic Trait - Define

<cb>trait <v>Trait1<>\<<v>T<>> {
	<v>...<>
}<>


#### Generic Trait - Define, Bounded

<cb>trait <v>Trait1<>\<<v>T<>: <v>Trait2<>> {
	<v>...<>
}<>

<cb>trait <v>Trait1<>\<<v>T<>: <v>Trait2<>, <v>U<>: <v>Trait3<>> {
	<v>...<>
}<>



Defines a trait that bounds a generic type to a second trait.

The generic <c>T<> must implement trait <c>Trait2<>.



#### Generic Trait - Implement

<cb>impl \<<v>T<>> <v>Trait1<>\<<v>T<>> for <v>SomeType<> {
	<v>...<>
}<>
@
@ for



### Generics Syntax


#### Generics - Equivalent Syntax

<cb>fn a_function\<<v>T<>: <v>Trait1<>>(<v>param_1<>: <v>T<>) {
	\<v>...\<>
}<>

<cb>fn a_function\<<v>T<>>(<v>param_1<>: <v>T<>)
	where <v>T<>: <v>Trait1<> {
	\<v>...\<>
}<>

<cb>fn a_function(<v>param_1<> impl <v>T<>) {
	\<v>...\<>
}<>


With Reference:

<cb>fn a_function\<<v>T<>: <v>Trait1<>>(<v>param_1<>: &<v>T<>) {
	\<v>...\<>
}<>

<cb>fn a_function\<<v>T<>>(<v>param_1<>: &<v>T<>)
	where <v>T<>: <v>Trait1<> {
	\<v>...\<>
}<>

<cb>fn a_function(<v>param_1<> &impl <v>T<>) {
	\<v>...\<>
}<>
@
@ where



# Lifetimes

Tells Rust how to determine the scope of variables passed into and out of a function.

Expicit Lifetime Syntax:

<cb>&'<v>a<> <v>T<>
&'<v>a<> mut <v>T<>
<v>T<>\<'<v>a<>><>
@
@ lifetime-only, lifetimes-only, 'a, 'b



### Lifetime - Define Function Lifetime

<cb>fn <v>function_1<>\<'<v>lifetime_1<>> (<v>param_1<>: &'<v>lifetime_1<> <v>type<>) -> &'<v>lifetime_1<> {
	<v>...<>
}<>

<cb>fn <v>function_1<>\<'<v>a<>, '<v>b<>> (<v>param_1<>: &'<v>a<> <v>type<>, <v>param_2<>: &'<v>b<> <v>type<>) -> &'<v>c<> {
	<v>...<>
}<>


Tells Rust what the lifetimes need to be for values entering and leaving the function.

A lifetime associated with an argument tells the compiler that the associated data must have the same scope and lifetime.



### Lifetime - Define Struct Lifetime

<cb>struct <v>Struct1<>\<'<v>a<>> {
	<v>field_1<>: &'<v>a<> <v>T<>
	<v>field_2<>: &'<v>a<> <v>T<>
}<>



### Lifetime - Eision Rules

3 Rules:

<*>Each Argument Is Assigned an Individual Lifetime
If Exactly 1 Argument, the Return Type Get The Same Lifetime
If <c>&self<> Is an Argument, the Return Type Gets The <c>self<> Lifetime<>


Rule 1:

<cb>fn function_1(<v>param_1<>: &<v>T<>, <v>param_2<>: &<v>T<>) -> &<v>T<>                   <#>// Elided<>
fn function_1<m>\<'a, 'b><>(<v>param_1<>: &<m>'a<> <v>T<>, <v>param_2<>: &<m>'b<> <v>T<>) -> &<m>'a<> <v>T<>  <#>// Compiler Expanded<><>

Rule 2:

<cb>fn function_1(<v>param_1<>: &<v>T<>) -> &<v>T<>                               <#>// Elided<>
fn function_1<m>\<'a><>(<v>param_1<>: &<m>'a<> <v>T<>) -> &<m>'a<> <v>T<>                     <#>// Compiler Expanded<><>

Rule 3:

<cb>fn function_1(&<v>self<>, <v>param_2<>: &<v>T<>) -> &<v>T<>                        <#>// Elided<>
fn function_1<m>\<'a, 'b><>(&<m>'a<> <v>self<>, <v>param_2<>: &<m>'b<> <v>T<>) -> &<m>'a<> <v>T<>       <#>// Compiler Expanded<><>



# Macros
@
@ macro-only, macros-only


# Macros - Standard
@
@ !

### Macro Basics

Macros are a compile time build tool that run inside your code.

<*>Run at Compile Time
Modify Source Code<>

Identified with <c>!<>

<cb><v>macro1!<>(<v>...<>)<>



### Todo Macro

<cb>todo!();<>


Use in functions where you haven't coded the result.

Prevents compiler errors while coding.
Will panic at runtime.


<cb>fn <v>incomplete_function<>() {
	todo!();
}<>


Rust Docs: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/macro.todo.html">todo<>
@
@ todo!()



# Modules

A module is a container for functions and types.

A module also defines a namespace for those functions and types.


Types:

<in>Inline Module
File Module (<m>term?<>)<>

Rust Docs: <l https://doc.rust-lang.org/reference/items/modules.html<>Modules<>
@
@ mod-only, mods-only, module-only, modules-only


### Modules - Inline Module



#### Modules - Inline Module - Define

<cb>mod <v>name<> {
	<v>...<>
}<>


### Modules - Visibility

Types:

	public / private

Default:

	private

Applies to:

	mod
	function
	struct
	struct field
	impl function
	trait

Keyword:

	pub


Accepts <c>pub<>?:

<card><table><col>mod<><col>Yes<>
<col> <>
<col>struct<><col>Yes<>
<col>struct field<><col>Yes<>
<col> <>
<col>impl<><col>No<>
<col>impl fn<><col>Yes<>
<col> <>
<col> <>
<col>Trait<><col>Yes<>
<col>Trait fn<><col>No<><col>(public by default)<><><>
@
@ pub



#### Module - Public Basics

<cb>pub struct <v>Public1<> {

	pub <v>public_field<>: <v>...<>,

	<v>private_field<>: <v>...<>,
}<>

<cb>impl <v>Public1<> {

	pub fn <v>public_function<>(&self) <v>...<>;

	fn <v>private_function<>(&self) <v>...<>;
}<>

<cb>pub trait <v>PublicTrait<> {

	fn <v>public_function<>(&self) <v>...<>; 
}<>



#### Module - Public Struct

<cb>pub struct <v>Public1<> {

	pub <v>public_field<>: <v>...<>,

	<v>private_field<>: <v>...<>,
}<>


#### Module - Public Trait

<cb>pub trait <v>PublicTrait<> {

	fn <v>public_function<>(&self) <v>...<>; 
}<>


Makes the trait public.

Trait functions are public by default.



#### Module - Public Function

<cb>pub fn <v>public_function_1<>() {<v>...<>}<>

<cb>mod <v>name<> {
	pub fn <v>public_function_1<>() {
		<v>...<>
	}
}<>


Use the keyword <v>pub<> to make a function public.
@
@ pub



#### Module - Private Function

No keyword <c>pub<>:

<cb>fn <v>public_function_1<>() {<v>...<>}<>

<cb>mod <v>name<> {
	fn <v>private_function_1<>() {
		<v>...<>
	}
}<>



### Module - Interface
The set of public functions and types in a module



### Module - Nested

<cb>mod <v>parent_mod<> {
	pub mod <v>nested_mod<> {
		<v>...<>
		pub fn <v>public_nested_func<>() {<v>...<>}

		fn <v>private_nested_func<>() {<v>...<>}
	}

	<v>nested_mod<>::<v>public_nested_func<>();
}

<v>parent_mod<>::<v>nested_mod<>::<v>public_nested_func<>();
<>



### Module - Structure - Public / Private Fields

<cb>mod <v>mod_1<> {
	
	pbu struct <v>Struct1<> {
		pub <v>publi_id<>: usize,
		<v>private_id<>: usize,
	}
}<>



# Traits

Traits defines shared methods and behaviour across types.

Traits can only access methods defined in the trait itself.
Traits can NOT be instantiated directly (istantiate the implementing type instead).
@
@ trait-only, traits-only



### Trait - Basics

Define:

<cb>trait <v>Trait1<> {
	fn <v>function_1<>();
	fn <v>function_2<>() -> Self;
	fn <v>method<>(&self):
}<>

Implement:

<cb>imp <v>Trait1<> for <v>Type<> {
	fn <v>function_1<>() {
		<v>...<>
	}
}<>

Call:

<cb>let <v>instance_1<> = <v>Type<>::new();
<v>instance_1<>.<v>function_1<>();<>



### Trait - Define

<cb>trait <v>TraitName<> {

	fn <v>function_1<>();
	fn <v>function_2<>() -> Self;
	fn <v>method<>(&self):
}<>



### Trait - Implement

<cb>impl <v>TraitName<> for <v>Type1<> {

	fn <v>traitFunction1<>(<v>...<>) {
		<v>...<>
	}
}<>


Implements a trait function for a given type.

Functions can be Type functions (call with ::) or instance methods (defined with &self parameter, called with '.').
@
@ impl for



### Trait - Function Parameter

<cb>fn <v>function_1<>(<v>param_1<>: impl <v>TraitName<>) {
	<v>...<>
}<>

<cb>fn <v>function_1<>(<v>param_1<>: &impl <v>TraitName<>) {
	<v>...<>
}<>

Passes an instance of the trait to the function.
@
@ pass, argument



### Trait - Function Parameter - Multiple Traits

<cb>fn <v>function_1<>(<v>param_1<>: impl <v>Trait1<> + <v>Trait2<> + <v>Trait3<>) {
	<v>...<>
}<>

<cb>fn <v>function_1<>(<v>param_1<>: &impl <v>Trait1<> + <v>Trait2<> + <v>Trait3<>) {
	<v>...<>
}<>

Passes an instance that implements all traits to the function.
@
@ pass, argument



### Trait - Dynamic Function Parameter

<cb>fn <v>function_1<>(<v>param_1<>: Box\<dyn <v>TraitName<>>) {
	<v>...<>
}<>

<cb>fn <v>function_1<>(<v>param_1<>: &Box\<dyn <v>TraitName<>>) {
	<v>...<>
}<>

Passes an instance of the trait where the actual type is not known at compile time.
@
@ pass, argument, dyn, &dyn, box



# Unsafe


### Unsafe - Basics

Allows you to:

<*>Dereference a Raw Pointer
Read from / Write To a Mutable Variable
Read from / Write To an External Static Variable
Access a Union Field (but not assign to it)
Call an Unsafe Function
Call an External C Function (Unsafe by default?)
Implement an Unsafe Trait<>

Used by:

<*>Frameworks
Special Packages<>



### Unsafe Syntax

<cb>unsafe {
	<v>...<>
}<>



# Formatting
@
@ formats, format-only, formats-only
@ formatting, formatting-only, formattings-only
@ as string, to string


### Format - To Binary

Format:

<cb>"{:b}"
"{:08b}"<>

Usage:

<cb>= format!("{:b}", &<v>value<>)<>

<cb>println!("{:b}", &<v>value<>)<>


Prints the binary form of a value.


Examples:

<cb>println!("{:b}", 11);		<#>// 1011<>
println!("{:08b}", 11);		<#>// 00001011<>
println!("{:016b}", 11);	<#>// 0000000000001011<><>

<cb>let <v>value<> = 11;
let <b>binary<> = format!("{:b}", value);

println!("{} decimal = {} binary.", &<v>value<>, &<v>binary<>);

<#>// Prints: 11 decimal = 1011 binary.<><>
@
@ integer, i8, i16, i32, i64, i128
@ u8, u16, u32, u64, fu128, usize 
@ convert, conversion
@ :b, :08b, {:b}, {:08b}


### Format - To Binary With Leading 0b

Format:

<cb>"{:#b}"
"{:#08b}"<>

Usage:

<cb>= format!("{:#b}", &<v>value<>)<>

<cb>println!("{:#b}", &<v>value<>)<>


Prints the binary form of a value with leading '0b'.


Examples:

<cb>println!("{:#b}", 11);		<#>// <b>0b<>1011<>
println!("{:#08b}", 11);	<#>// <b>0b<>00001011<><>

<cb>let <v>value<> = 11;
let <b>binary<> = format!("{:#b}", value);

println!("{} decimal = {} binary.", &<v>value<>, &<v>binary<>);

<#>// Prints: 11 decimal = 0b1011 binary.<><>
@
@ integer, i8, i16, i32, i64, i128
@ u8, u16, u32, u64, fu128, usize 
@ convert, conversion, :b, :#b, {:b}, {:#b}



### Format - To Hexadecimal (Lower Case)

Format:

<cb>"{:x}"
"{:02x}"
"{:04x}"<>

Usage:

<cb>= format!("{:x}", &<v>value<>)<>

<cb>println!("{:x}", &<v>value<>)<>


Prints the lower case hexadecimal form of a value.


Examples:

<cb>println!("{:x}", 42);		<#>// 2a<>
println!("{:02x}", 42);		<#>// 2a<>
println!("{:04x}", 42);		<#>// 002a<><>

<cb>let <v>value<> = 42;
let <b>hex<> = format!("{:04x}", value);

println!("{} decimal = {} hex.", &<v>value<>, &<v>hex<>);

<#>// Prints: 42 decimal = 002a hex.<><>
@
@ integer, i8, i16, i32, i64, i128
@ u8, u16, u32, u64, fu128, usize
@ {:x}, :x, {:02x}, :02x, {:04x}, :04x
@ convert, conversion



### Format - To Hexadecimal (Upper Case)

Format:

<cb>"{:X}"
"{:02X}"
"{:04X}"<>

Usage:

<cb>= format!("{:X}", &<v>value<>)<>

<cb>println!("{:X}", &<v>value<>)<>


Returns the upper case hexadecimal form of a value.


Examples:

<cb>println!("{:X}", 42);		<#>// 2A<>
println!("{:02X}", 42);		<#>// 2A<>
println!("{:04X}", 42);		<#>// 002A<><>

<cb>let <v>value<> = 42;
let <b>hex<> = format!("{:04X}", value);

println!("{} decimal = {} hex.", &<v>value<>, &<v>hex<>);

<#>// Prints: 42 decimal = 002A hex.<><>
@
@ integer, i8, i16, i32, i64, i128
@ u8, u16, u32, u64, fu128, usize 
@ {:x}, :x, {:02x}, :02x, {:04x}, :04x
@ convert, conversion



### Format - To Hexadecimal With Leading 0x

Format:

<cb>"{:#x}"
"{:#04x}"
"{:#06x}"<>

Usage:

<cb>= format!("{:#04x}", &<v>value<>)<>

<cb>println!("{:#04x}", &<v>value<>)<>


Returns the hexadecimal form of a value with a leading '0x'.

Note: The padding length refers to the total length of the returned string.

<in><c>format!("{:#04x}", 42)<> returns "0xa2".<>


Examples:

<cb>println!("{:#x}", 42);		<#>// <b>0x<>2a<>
println!("{:#02x}", 42);	<#>// 0x2a<>
println!("{:#04x}", 42);	<#>// 0x2a<>
println!("{:#06x}", 42);	<#>// 0x002a<><>

<cb>let <v>value<> = 42;
let <b>hex<> = format!("{:#06x}", value);

println!("{} decimal = {} hex.", &<v>value<>, &<v>hex<>);

<#>// Prints: 42 decimal = 0x002a hex.<><>
@
@ integer, i8, i16, i32, i64, i128
@ u8, u16, u32, u64, fu128, usize 
@ convert, conversion, hash
@ {:x}, :x, {:02x}, :02x, {:04x}, :04x, {:06x}, :06x
@ {:#x}, :#x, {:#02x}, :#02x, {:#04x}, :04x, {:#06x}, :06x



# Files
@
@ files-only, file-only, fs::


## File - Properties


### File - Exists?

<cb>= <v>path_1<>.exists()<>

Usage:

<cb>use std::path::Path;

let <v>path_1<> = Path::new("<v>path<>");
= <v>path_1<>.exists()<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/path/index.html">path<>::<l https://doc.rust-lang.org/stable/std/path/struct.Path.html>Path<>
@
@ path.exists(), .exists(), path



### File - Get Metadata

<cb>= metadata("<v>path<>")<>

Usage:

<cb>use std::fs::metadata;

= metadata("<v>path<>")<>

Returns:

<cb>Result\<Metadata><>


Returns the metadata for a file.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/fn.metadata.html>metadata<>
@
@ std::fs::metadata(), metadata()



### File - Get Created Date

<cb>= <v>metadata<>.created()<>

Usage:

<cb>use std::fs::metadata;

let <v>metadata<> = metadata("<v>path<>")?;

<v>...<> = <v>metadata<>.created();<>

Returns:

<cb>Result\<SystemTime><>


Returns the created system time for a file.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.Metadata.html>Metadata<>.<l https://doc.rust-lang.org/std/fs/struct.Metadata.html#method.created>created<>
@
@ std::fs::metadata, metadata.created(), .created()



### File - Get Modified Date

<cb>= <v>metadata<>.modified()<>

Usage:

<cb>use std::fs::metadata;

let <v>metadata<> = metadata("<v>path<>")?;

<v>...<> = <v>metadata<>.modified();<>

Returns:

<cb>Result\<SystemTime><>


Returns the created system time for a file.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.Metadata.html>Metadata<>.<l https://doc.rust-lang.org/std/fs/struct.Metadata.html#method.modified>modified<>
@
@ std::fs::metadata, metadata.modified(), .modified()



### File - Is Directory

<cb>= <v>metadata<>.is_dir()<>

Usage:

<cb>use std::fs::metadata;

let <v>metadata<> = metadata("<v>path<>")?;

<v>...<> = <v>metadata<>.is_dir();<>

Returns:

<cb>bool<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.Metadata.html>Metadata<>.<l https://doc.rust-lang.org/std/fs/struct.Metadata.html#method.is_dir>is_dir<>
@
@ std::fs::metadata, metadata.is_dir(), .is_dir()



### File - Is File

<cb>= <v>metadata<>.is_file()<>

Usage:

<cb>use std::fs::metadata;

let <v>metadata<> = metadata("<v>path<>")?;

<v>...<> = <v>metadata<>.is_file();<>

Returns:

<cb>bool<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.Metadata.html>Metadata<>.<l https://doc.rust-lang.org/std/fs/struct.Metadata.html#method.is_file>is_file<>
@
@ std::fs::metadata, metadata.is_file(), .is_file()



### File - Is Symbolic Link

<cb>= <v>metadata<>.is_symlink()<>

Usage:

<cb>use std::fs::metadata;

let <v>metadata<> = metadata("<v>path<>")?;

<v>...<> = <v>metadata<>.is_symlink();<>

Returns:

<cb>bool<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.Metadata.html>Metadata<>.<l https://doc.rust-lang.org/std/fs/struct.Metadata.html#method.is_symlink>is_symlink<>
@
@ std::fs::metadata, metadata.is_symlink(), .is_symlink(), symlink, sym link



## File Operations
@
@ ops-only


### Directory - Delete - Empty

<cb>remove_dir("<v>path<>");<>

Usage:

<cb>use std::fs::remove_dir;

remove_dir("<v>path<>");<>

Returns:

<cb>Result\<()><>


Deletes an empty directory.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/stable/std/fs/fn.remove_dir.html>remove_dir<>
@
@ remove directory
@ std::fs::remove_dir(), fs::remove_dir(), remove_dir(), delete_dir()



### Directory - Delete - Non Empty

<cb>remove_dir_all("<v>path<>");<>

Usage:

<cb>use std::fs::remove_dir_all;

remove_dir("<v>path<>");<>

Returns:

<cb>Result\<()><>


Deletes a directory and all its contents.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/stable/std/fs/fn.remove_dir_all.html>remove_dir_all<>

@
@ remove directory
@ std::fs::remove_dir_all(), fs::remove_dir_all(), remove_dir_all(), delete_dir()



### File - Delete

<cb>remove_file("<v>path<>");<>

Usage:

<cb>use std::fs::remove_file;

remove_file("<v>path<>");<>

Returns:

<cb>Result\<()><>


Deletes a file.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/stable/std/fs/fn.remove_file.html>remove_file<>

@
@ remove file
@ std::fs::remove_file(), fs::remove_file(), remove_file(), delete_file()




## File IO
@
@ file-io-only



### Create Empty File

<cb>File::create("<v>path<>")?;<>

Usage:

<cb>use std::fs::File;

File::create("<v>path<>")?;<>


This will create an empty file (0 bytes).
@
@ std::fs::file::create(), fs::file::create(), file::create(), create()



### Binary File - Read

<cb>= read(<v>path<>)<>

Usage:

<cb>use std::fs::read;

= read(<v>path<>)<>

Returns:

<cb>Result\<Vec\<u8>><>


Reads a file in as bytes (u8).


Example:

<cb>use std::fs::read;

let <v>contents<> = read("<v>contents.txt<>")
		.expect("Couldn't read the file.");

println!("{:?}", <v>contents<>);<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/stable/std/fs/fn.read_to_string.html>read_to_string<>
@
@ std::fs::read(), fs::read(), read()
@ vec\<u8>, bytes



### Binary File - Read 2

<cb>let mut <v>file<> = File::open("<v>path<>")?;
let mut <v>contents<>: Vec\<u8> = Vec::new();
<v>file<>.read_to_end(&mut <v>contents<>)?;<>

Usage:

<cb>use std::fs::File;
use std::io::prelude::*;

let mut <v>file<> = File::open("<v>path<>")?;
let mut <v>contents<>: Vec\<u8> = Vec::new();
<v>file<>.read_to_end(&mut <v>contents<>)?;<><>

Returns:

<cb>Result\<Vec\<u8>><>


Reads a file in as a bytes (u8).


Example:

<cb>use std::fs::File;
use std::io::prelude::*;

let mut <v>file<> = File::open("<v>contents.txt<>")
		.expect("Couldn't read the file.");

let mut <v>contents<>: Vec\<u8> = Vec::new();

<v>file<>.read_to_end(&mut <v>contents<>)
		.expect("Couldn't read the file.");

println!("{:?}", <v>contents<>);<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>.<l https://doc.rust-lang.org/std/fs/struct.File.html#method.read_to_end>read_to_end()<>
@
@ std::fs
@ std::fs::read(), fs::read(), read()
@ vec\<u8>, bytes



### Binary File - Write

<cb>= write(<v>path<>)<>

Usage:

<cb>use std::fs::write;

fs::write(<v>path<>).expect(<v>error_message<>)<>

Returns:

<cb>Result\<()><>


Writes a file out as bytes (u8).

Will overwrite any existing file.
Internally calls <c>File.create()<> then <c>file.write_all()<>.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/stable/std/fs/fn.write.html>write<>
@
@ std::fs::write(), fs::write(), .write()
@ Vec\<u8>, bytes



### Binary File - Write 2

<cb>let mut <v>file<> = File::create(<v>path<>)?;
<v>file<>.write_all(<v>bytes_1<>);<>

Or:

<cb>writeln!(<v>file<>, "{}", <v>bytes_1<>);<>

Usage:

<cb>use std::fs::File;
use std::io::prelude::*;

let mut <v>file<> = File::create(<v>path<>)?;
<v>file<>.write_all(<v>bytes_1<>)?;<>

Returns:

<cb>Result\<()><>


Writes a vector of bytes to a file using an instance of <c>File<>.

Will overwrite any existing file.
The file is closed automatically when the variable goes out of scope.


Example:

<cb>use std::fs::File;
use std::io::prelude::*;

let <v>bytes<>: Vec\<u8> = Vec![66, 121, 116, 101, 115, 33];

let mut <v>file<> = File::create("example.txt")
		.expect("Could not create file.");

<v>file<>.write_all(& <v>bytes<>)
		.expect("Could not write to file.");<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>.<l https://doc.rust-lang.org/std/fs/struct.File.html#method.write>write()<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>.<l https://doc.rust-lang.org/std/fs/struct.File.html#method.write_all>write_all()<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l https://doc.rust-lang.org/std/macro.writeln.html>writeln!<>
@
@ std::fs::file
@ file.write(), write(), file.write_all(), write_all()
@ Vec\<u8>, bytes



### Binary File - Append

<cb>let mut file = File::options().append(true).open(<v>path<>)?;
<v>file<>.write_all(<v>bytes_1<>);<>

Usage:

<cb>use std::fs::File;
use std::io::prelude::*;

let mut <v>file<> = File::create(<v>path<>)?;
<v>file<>.write_all(<v>bytes_1<>)?;<>

Returns:

<cb>Result\<()><>


Appends a vector of bytes to a file using an instance of <c>File<>.

Will throw an error if the file does not exist
The file is closed automatically when the variable goes out of scope.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>.<l https://doc.rust-lang.org/std/fs/struct.File.html#method.write>write()<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>.<l https://doc.rust-lang.org/std/fs/struct.File.html#method.write_all>write_all()<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l https://doc.rust-lang.org/std/macro.writeln.html>writeln!<>
@
@ std::fs::file
@ file.write(), write(), file.write_all(), write_all()
@ vec\<u8>, bytes, add, write



### Text File - Read

<cb>= read_to_string("<v>path<>)<>

Usage:

<cb>use std::fs::read_to_string;

= read_to_string("<v>path<>")<>

Returns:

<cb>Result\<String><>


Reads a file in as a string.


Example:

<cb>use std::fs::read_to_string;

let <v>contents<> = read_to_string("<v>contents.txt<>")
		.expect("Couldn't read the file.");

println!("{}", <v>contents<>);<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/stable/std/fs/fn.read_to_string.html>read_to_string<>
@
@ std::fs::read_to_string(), fs::read_to_string(), read_to_string()
@ String



### Text File - Read 2

<cb>let mut <v>file<> = File::open("<v>path<>")?;
let mut <v>contents<> = String::new();
<v>file<>.read_to_string(&mut <v>contents<>)?;<>

Usage:

<cb>use std::fs::File;
use std::io::prelude::*;

let mut <v>file<> = File::open("<v>path<>")?;
let mut <v>contents<> = String::new();
<v>file<>.read_to_string(&mut <v>contents<>)?;<><>

Returns:

<cb>Result\<String><>


Reads a file in as a string.


Example:

<cb>use std::fs::File;
use std::io::prelude::*;

let mut <v>file<> = File::open("<v>contents.txt<>")
		.expect("Couldn't read the file.");

let mut <v>contents<> = String::new();

<v>file<>.read_to_string(&mut <v>contents<>)
		.expect("Couldn't read the file.");

println!("{}", <v>contents<>);<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>.<l https://doc.rust-lang.org/std/fs/struct.File.html#method.read_to_string>read_to_string()<>
@
@ std::fs::file, file.read_to_string(), .read_to_string()
@ String



### Text File - Read Lines

<cb>let <v>contents<> = read_to_string(<v>path<>)?
let <v>lines<>: Vec\<&str> = <v>contents<>.lines().collect();<>

Returns:

<cb>Vec\<&str><>

<cb>let <v>contents<> = read_to_string(<v>path<>)?
let <v>lines<>: Vec\<&str> = <v>contents<>.lines().map(|value| value.to_string()).collect();<>

Returns:

<cb>Vec\<String><>


Reads a file in as a vectors of lines.


Example:

<cb>use std::fs::read_to_string;

let <v>contents<> = read_to_string("<v>contents.txt<>")
		.expect("Couldn't read the file.");

let lines: Vec\<String> = <v>contents<>.lines().map(|value| value.to_string()).collect();

for line in lines {
	println!("{}", <v>line<>);
}<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/fn.read_to_string.html>read_to_string<>
@
@ std::fs::File, file.lines(), .lines()
@ String, Vec\<&str>



### Text File - Write

<cb>fs::write(<v>path<>, <v>contents<>);<>

Usage:

<cb>use std::fs;

fs::write(<v>path<>, <v>contents<>.as_bytes());<>

Returns:

<cb>Result\<()><>


Writes a string to a file.

Will overwrite any existing file.
Internally calls <c>File.create()<> then <c>file.write_all()<>.


Example:

<cb>use std::fs::write;

let <v>contents<> = "File contents.";

write("example.txt", & <v>contents<>.as_bytes())
		.expect("Could not write to file.");<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/fn.write.html>write<>
@
@ std::fs
@ fs::write(), .write()
@ String



### Text File - Write 2

<cb>let mut <v>file<> = File::create(<v>path<>)?;
<v>file<>.write_all(<v>contents<>.as_bytes());<>

Or:

<cb>writeln!(<v>file<>, "{}", <v>contents<>);<>

Usage:

<cb>use std::fs::File;
use std::io::prelude::*;

let mut <v>file<> = File::create(<v>path<>)?;
<v>file<>.write_all(<v>contents<>.as_bytes())?;<>

Returns:

<cb>Result\<()><>


Writes a string out to a file using an instance of <c>File<>.

Will overwrite any existing file.
The file is closed automatically when the variable goes out of scope.


Example:

<cb>use std::fs::File;
use std::io::prelude::*;

let <v>contents<> = "File contents.";

let mut <v>file<> = File::create("example.txt")
		.expect("Could not create file.");

<v>file<>.write_all(& <v>contents<>.as_bytes())
		.expect("Could not write to file.");<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>.<l https://doc.rust-lang.org/std/fs/struct.File.html#method.write>write()<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>.<l https://doc.rust-lang.org/std/fs/struct.File.html#method.write_all>write_all()<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l https://doc.rust-lang.org/std/macro.writeln.html>writeln!<>
@
@ std::fs::file
@ file.write(), write(), file.write_all(), write_all(), writeln!(), writeln()
@ String


### Text File - Write Lines

<cb>let mut <v>file<> = File::create(<v>path<>)?;
for <v>line<> in <v>lines<> {
	writeln!(<v>file<>, "{}", <v>line<>)?;
}<>

Usage:

<cb>use std::fs::File;
use std::io::prelude::*;

let mut <v>file<> = File::create(<v>path<>)?;
for <v>line<> in <v>lines<> {
	writeln!(<v>file<>, "{}", <v>line<>)?;
}<>

Returns:

<cb>Result\<()><>


Writes a list of strings to a file.

Will overwrite any existing file.
A newline is automatically appended at the end of each line by <c>writeln!()<>
The file is closed automatically when the variable goes out of scope.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l https://doc.rust-lang.org/std/macro.writeln.html>writeln!<>
@
@ std::fs::file
@ writeln!(), writeln()
@ list of Strings, sequence



### Text File - Append

<cb>let mut file = File::options().append(true).open(<v>path<>)?;
<v>file<>.write_all(<v>contents<>.as_bytes());<>

Or:

<cb>let mut file = File::options().append(true).open(<v>path<>)?;
writeln!(<v>file<>, "{}", <v>contents<>);<>

Usage:

<cb>use std::fs::File;
use std::io::prelude::*;

let mut <v>file<> = File::create(<v>path<>)?;
<v>file<>.write_all(<v>contents<>.as_bytes())?;<>

Returns:

<cb>Result\<()><>


Appends a string to a file using an instance of <c>File<>.

Will throw an error if the file does not exist
The file is closed automatically when the variable goes out of scope.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>.<l https://doc.rust-lang.org/std/fs/struct.File.html#method.write>write()<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>.<l https://doc.rust-lang.org/std/fs/struct.File.html#method.write_all>write_all()<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l https://doc.rust-lang.org/std/macro.writeln.html>writeln!<>
@
@ std::fs::file
@ file.write(), write(), file.write_all(), write_all(), writeln!(), writeln()
@ String, add, write



### write() vs write_all()


fs::write():

<*>Calls: File::open(), file.write_all()<>


file.write():

<*>Writes Bytes To The File
Returns The Number Of Bytes Written<>

<*>Will Attempt To Write All Bytes
Not An Error If Not All Bytes Are Written<>


file.write_all():

<*>Writes <_>All<> Bytes To The File
Returns Nothing<>

<*>Internally Calls <c>write()<> Until All Bytes Written<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/fn.write.html>write<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>.<l https://doc.rust-lang.org/std/fs/struct.File.html#method.write>write()<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fs/index.html">fs<>::<l https://doc.rust-lang.org/std/fs/struct.File.html>File<>.<l https://doc.rust-lang.org/std/fs/struct.File.html#method.write_all>write_all()<>
@
@ file.write(), .write(), file.write_all(), .write_all()
@ std::fs::file



# Threads
@
@ thread-only, threads-only


### Thread - Create

<cb>spawn(move || { <v>...<> }<>

Usage:

<cb>use std::thread::spawn;

let <v>thread_1<> = spawn(|| {
	<v>...<>
});<>


Spawns a new thread.
@
@ thread::spawn(), spawn()



### Thread - Create - Move Closure Ownership

<cb>spawn(move || { <v>...<> }<>

Usage:

<cb>use std::thread::spawn;

let <v>thread_1<> = thread::spawn(move || {
	<v>...<>
});<>


Spawns a new thread and calls the closure.

The closure takes ownership of all variables in scope.



### Thread - Create With Builder

<cb>use std::thread;

let <v>thread_1<> = thread::Builder::new().name("<v>thread name<>".to_string()).spawn(move || {
	println!("Hello, world!");
});<>
@
@ std::thread::builder::new(), builder::new()



### Thread - Block For Results

<cb>= <v>thread_1<>.join()<>

Returns:

<cb>Result\<<v>T<>><>


Blocks until the thread completes then captures the returned value.
@
@ get return
@ thread.join(), .join()



## Channels

Creates an asynchronous channel that threads can use to communicate together.

Creates an MPSC (multi-producer single consumer) channel.

Rust Docs: <l https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html>Channel<>
Rust Docs: <l https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html>Sender<>
Rust Docs: <l https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html>Receiver<>
@
@ channel-only, channels-only


### Channel - Create

<cb>let (<v>sender<>, <v>receiver<>) = channel();<>

Usage:

<cb>use std::sync::mpsc::channel;
use std::sync::mpsc::Sender;
use std::sync::mpsc::Receiver;

let (<v>sender<>, <v>receiver<>): (Sender\<<v>T<>>, Receiver\<<v>T<>>) = channel();<>



### Channel Sender - Send

<cb>= <v>sender<>.send(<v>message<>);<>

Returns:

<cb>Result\<(), SendError\<<v>T<>>><>


Sends a message to the channel.
The message will be received on the channel receiver.
@
@ sender.send(), .send()



### Channel Receiver - Receive (Blocking)

<cb>= <v>receiver<>.recv()<>

Returns:

<cb>Result\<<v>T<>, RecvError\<<v>T<>>><>


Blocks until a message is received.
@
@ receiver.recv(), .recv()
@ receiver.receive(), .receive()



### Channel Receiver - Receive (Non-Blocking)

<cb>= <v>receiver<>.try_recv()<>

Returns:

<cb>Result\<<v>T<>, TryRecvError\<<v>T<>>><>


Checks to see if a message arrived.

Continues if none found.
@
@ receiver.recv(), .recv()
@ receiver.receive(), .receive()



# Operator Overloading / Implementing


### Implement Equals - Using Derive

<cb>#[derive(eq)]
struct <v>Type<> { <v>...<> }<>


To support the == and != operators, use the derive attribute.


Example:

<cb>#[derive(PartialEq)]
struct <v>Point<> {
	<v>x<>: i32,
	<v>y<>: i32
}

let <v>point_1<> = <v>Point<> { x: 10, y: 20 };
let <v>point_2<> = <v>Point<> { x: 20, y: 10 };

println!("Point 1 == 2?: {}", <v>point_1<> == <v>point_2<>);

<#>// Prints: Point 1 == 2?: false<><>
@
@ ==, !=, #derive, #[derive(PartialEq)], partialeq



### Implement Equals - Using Trait

<cb>impl PartialEq\<<v>Type<>> for <v>Type<> {

	fn eq(&self, other: &<v>Type<>) -> bool {
		self.<v>...<> == other.<v>...<>
	}
}<>


To support the == and != operators, implement the PartialEq trait.


Example:

<cb>struct <v>Point<> {
	<v>x<>: i32,
	<v>y<>: i32
}

impl PartialEq\<<v>Point<>> for <v>Point<> {

	fn eq(&self, other: &<v>Point<>) -> bool {
		self.<v>x<> == other.<v>x<> && self.<v>y<> == other.<v>y<>
	}
}

let <v>point_1<> = <v>Point<> { x: 10, y: 20 };
let <v>point_2<> = <v>Point<> { x: 20, y: 10 };

println!("Point 1 == 2?: {}", <v>point_1<> == <v>point_2<>);

<#>// Prints: Point 1 == 2?: false<><>
@
@ ==, !=, partialeq, impl



# Standard Enum Types
@
@ std-enum-types, standard-enum-types, system-enum-types, sys-enum-types


## Option

<cb>Option\<<v>Type<>><>

Type: <c>std::option::Option<>


Use to define instances where a call may or may not return a value.

Option is an enum with 2 values: Some, None.
If assigning <c>None<>, you must define the type.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/option/index.html">option<>::<l "https://doc.rust-lang.org/std/option/enum.Option.html">Option<>
@
@ None, Some(), optional
@ options, optionals, option-only, options-only
@ std::option::Option


### Option - Basics

<cb>let <v>item_1<> = Some(<v>value_1<>);
let <v>item_2<>: Option\<<v>Type<>> = None;<>

<cb>let <v>item_1_value<> = match <v>item_1<> {
	Some(<v>value<>) => <v>value<>,
	None => "[No Value]"
};

println!("item 1 value = {}", <v>item_1_value<>);<>

<cb>let <v>item_2_value<> = <v>item_2<>.unwrap_or("[No Value]");

println!("item 2 value = {}", <v>item_2_value<>);<>



### Option - Create
@
@ define, new, instantiate


#### Option - Create Some

<cb>= Some(<v>value<>)<>


Creates an <c>Option<> variable with a value.

Option is an enum with 2 values: Some, None.
If assigning <c>None<>, you must define the type.


Example:

<cb>let <v>some_value<> = Some(42);<><>



#### Option - Create None

<cb>= None<>

Usage:

<cb>let <v>item<>: Option\<<v>Type<>> = None;<>


Creates an <c>Option<> variable with no value.

when assigning <c>None<>, you must define the type.


Example:

<cb>let <v>no_value<>: Option\<i32> = None;<>



### Option - Operations
@
@ options, optionals, option-only, options-only
@ std::option::Option
@ data type


#### Option - Get Value

<cb>= <v>optional_1<>.unwrap()<>
@
@ .unwrap()



#### Option - Get Value Or Default Value

<cb>= <v>optional_1<>.unwrap_or(<v>default_value<>)<>

Returns unwrapped value or if None, returns a default value.


Example:

Passing Lambda:

<cb>let no_value: Option<&str> = None;

let <v>unwrapped<> = <v>no_value<>.unwrap_or("[No Value]");
println!("Unwrapped = {}", <v>unwrapped<>);

<#>// Prints "Unwrapped = [No Value]"<><>
@
@ .unwrap_or()



#### Option - Get Value Or Call Function

<cb>= <v>optional_1<>.unwrap_or_else(<v>function_1<>)<>

Returns unwrapped value or if None, calls parameter function.


Example:

Passing Lambda:

<cb>let no_value: Option<&str> = None;

let <v>unwrapped<> = <v>no_value<>.unwrap_or_else(|| "[No Value]");
println!("Unwrapped = {}", <v>unwrapped<>);

<#>// Prints "Unwrapped = [No Value]"<><>
@
@ .unwrap_or_else()



#### Option - Match

<cb>match <v>optional_1<> {
	Some(<v>value<>) => {
		<v>...<>
	}
	None => {
		<v>...<>
	}
}<>


Use <c>match<> to process an <c>Option<> variable.


Example:

<cb>let <v>optional_int<> = Some(4);

match <v>optional_int<> {
	Some(<v>value<>) => {
		println!("Optional value is {}.", <v>value<>);
	}
	None => {
		println!("Optional value is None.");
	}
}

<#>// Prints "Optional value is 4."<><>
@
@ Some(), None



## Result

<cb>Result\<<v>Type<>, <v>Error<>><>

Type: <c>std::result::Result<>


Use to return a data or an error from a function.

Result is an enum with 2 values: <c>Ok()<>, <c>Err()<>.
Return a good result with <c>Ok()<>.
Return an error with <c>Err()<>.
Err requires an error object be returned with the error.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/result/index.html">result<>::<l "https://doc.rust-lang.org/std/result/enum.Result.html">Result<>
@
@ Ok(), Err()
@ results, result-only, results-only, res-only
@ std::result::Result


### Result - Basics

<cb>fn <v>some_function<>() -> Result\<<v>Type<>, <v>Error<>> {

	<#>// Return good result:<>
	return Ok(<v>value<>);

	<#>// Return error:<>
	return Err(<v>error<>);
}<>

Propagate Recoverable Error:

<cb>fn <v>call_some_function<>() -> Result\<<v>Type<>, <v>Error<>> {

	return <v>some_function<>()?;
}<>

Handle Result:

<cb>match <v>result<> {
	Ok(<v>value<>) => {	<v>...<> }
	Err(<v>error<>) => { <v>...<> }
}<>



### Result - Create
@
@ define, new, instantiate


#### Result - Create Result Value

<cb>= OK(<v>value<>)<>

Usage:

<cb>fn <v>some_function<>() -> Result\<<v>Type<>, <v>Error<>> {
	return OK(<v>value<>);
}<>


Creates an <c>Result<> variable with a value.


Example:

<cb>return Ok(<v>42<>);<><>
@
@ Ok()



#### Result - Create Error

<cb>= Err(<v>error<>)<>

Usage:

<cb>fn <v>some_function<>() -> Result\<<v>Type<>, <v>Error<>> {
	return Err(<v>error<>);
}<>


Creates an error <c>Result<>.



### Result - Properties



#### Result - Get Error

<cb>= <v>result_1<>.err()<>

Returns:

<cb>Option\<E><>


Returns the error value or None.
@
@ result.err(), .err()



#### Result - Get OK

<cb>= <v>result_1<>.ok()<>

Returns:

<cb>Option\<T><>


Returns the ok value or None.
@
@ result.ok(), .ok()



#### Result - Is Error?

<cb>= <v>result_1<>.is_err()<>

Returns true if the result is an error.
@
@ result.is_err(), .is_err()



#### Result - Is OK?

<cb>= <v>result_1<>.is_ok()<>

Returns true if the result is successful.
@
@ result.is_ok(), .is_ok()



### Result - Operations
@
@ resultss, result-only, results-only
@ std::result::Result


#### Result - Get Value

<cb>= <v>result_1<>.unwrap()<>
@
@ .unwrap()



#### Result - Get Value Or Default Value

<cb>= <v>result_1<>.unwrap_or(<v>error_value<>)<>

Returns unwrapped value or if None, returns a default value.
@
@ .unwrap_or()



#### Result - Get Value Or Call Function

<cb>= <v>result_1<>.unwrap_or_else(<v>function_1<>)<>

Returns unwrapped value or if None, calls parameter function.
@
@ .unwrap_or_else()



#### Result - Match

<cb>match <v>result_1<> {
	Ok(<v>value<>) => {
		<v>...<>
	}
	Err(<v>error<>) => {
		<v>...<>
	}
}<>


Use <c>match<> to process an <c>Result<> variable.
@
@ Ok(), Err()



# Standard Collection Types
@
@ standard-collection-types, std-coll-types, system-collection-types, sys-coll-types


## BtreeMap

A Sorted Map

Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/collections/index.html">collections<>::<l "https://doc.rust-lang.org/std/collections/struct.BTreeMap.html">BTreeMap<>
@
@ btree-only, btrees-only,  btreemap-only, btreemaps-only



## BtreeSet

A Sorted Set

Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/collections/index.html">collections<>::<l "https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">BTreeSet<>
@
@ btree-only, btrees-only,  btreeset-only, btreesets-only



## HashMap

<cb>HashMap\<<v>Key<>, <v>Value<>><>

Type: <c>std::collections::HashMap<>


A Collection of Key Values Stored on the Heap


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/collections/index.html">collections<>::<l https://doc.rust-lang.org/std/collections/struct.HashMap.html>HashMap<>
@
@ std::collections::HashMap
@ hashmap-only, hashmaps-only, hashmaps


### HashMap - Create
@
@ define, new, instantiate


#### HashMap - Create

<cb>= HashMap::new()<>

Usage:

<cb>use std::collections::HashMap;

let mut <v>hashmap_1<>: HashMap\<<v>Key<>, <v>Value<>> = HashMap::new();<>

Returns:

<cb>HashMap\<<v>Key<>, <v>Value<>><>


Creates an instance of HashMap.


Example:

<cb>use std::collections::HashMap;

let mut <v>hashmap_1<> = HashMap::new();

<v>hashmap_1<>.insert("<v>one<>", "<v>Value 1<>");
<v>hashmap_1<>.insert("<v>two<>", "<v>Value 2<>");

let <v>value<> = &<v>hashmap_1<>.get(&"<v>one<>");

println!("{}", <v>value<>.unwrap());

<#>// Prints: "Value 1"<><>
@
@ new, define, instantiate
@ hashmap::new(), new()
@ _model_


#### HashMap - Create From Array

<cb>= HashMap::from([
	(<v>key_1<>, <v>value_1<>),
	(<v>key_2<>, <v>value_2<>),
	(<v>key_3<>, <v>value_3<>),
	<v>...<>
])<>


Creates a HashMap from a list of key value tuples.
@
@ hashmap::from(), from()



### HashMap - Properties


#### HashMap - Capacity

<cb>= <v>hashmap_1<>.capacity(<v>key<>)<>

Returns:

<cb>usize<>


Returns the maximum number of items the HashMap can store.
@
@ hashmap.capacity(), .capacity()



#### HashMap - Contains Key

<cb>= <v>hashmap_1<>.contains_key(<v>key<>)<>
@
@ hashmap.contains_key(), .contains_key()



#### HashMap - Get

<cb>= <v>hashmap_1<>.get(<v>key<>)<>

Returns:

<cb>Option\<&<v>Value<>><>


Returns the value for the given key.
@
@ item, element, value
@ hashmap.get(), .get()



#### HashMap - Get Keys

<cb>= <v>hashmap_1<>.keys()<>

Returns:

<cb>Keys\<<v>Key<>, <v>Value<>> 	<#>// Iterator<><>


Returns an iterator for all keys.

Takes O(capacity) time to execute (vs the shorter O(length) time).
Prefer <l "?q=btreemap-only">BTreeMap<> if doing this a lot or on a large data set.
@
@ iterator, iterate
@ hashmap.keys(), .keys()



#### HashMap - Get Values

<cb>= <v>hashmap_1<>.values()<>

Returns:

<cb>Values\<<v>Key<>, <v>Value<>> 	<#>// Iterator<><>


Returns an iterator for all values.

Takes O(capacity) time to execute (vs the shorter O(length) time).
Prefer <l "?q=btreemap-only">BTreeMap<> if doing this a lot or on a large data set.
@
@ items, elements, values
@ iterator, iterate
@ hashmap.values(), .values()



#### HashMap - Is Empty?

<cb>= <v>hashmap_1<>.is_empty()<>

Returns:

<cb>bool<>
@
@ hashmap.is_empty(), .is_empty()



#### HashMap - Iterate

<cb>for (<v>key<>, <v>value<>) in <v>hashmap_1<>.iter() {
	<v>...<>
}<>


Iterates over the key value pairs in the HashMap.

Takes O(capacity) time to execute (vs the shorter O(length) time).
Prefer <l "?q=btreemap-only">BTreeMap<> if doing this a lot or on a large data set.
@
@ over elements, over items, over key value pairs
@ hashmap.iter(), .iter()



#### HashMap - Length

<cb>= <v>hashmap_1<>.len()<>

Returns:

<cb>usize<>


Returns the number of items in the hashmap.
@
@ count, length, size
@ hashmap.len(), .len()



### HashMap - Operations


#### HashMap - Clear

<cb><v>hashmap_1<>.clear();<>

Removes all elements from the hashmap.
@
@ remove all, delete all
@ hashmap.clear(), .clear()



#### HashMap - Insert

<cb><v>hashmap_1<>.insert(<v>key<>, <v>value<>);<>


Inserts an item into the hashmap.

Will overwrite existing item if one exists.
@
@ add
@ item, element, value
@ hashmap.insert(), .insert()



#### HashMap - Remove

<cb>= <v>hashmap_1<>.remove(<v>key<>)<>

Returns:

<cb>Option\<Value><>


Removes and returns the item with the given key.
@
@ hashmap.remove(), .remove()
@ delete
@ item, element, value



## HashSet

<cb>HashSet\<<v>T<>><>

Type:

<cb>std::collections::HashSet<>

An Unordered Set of Values Stored on the Heap


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/collections/index.html">collections<>::<l https://doc.rust-lang.org/std/collections/struct.HashSet.html>HashSet<>
@
@ hashset-only, hashsets-only
@ std::collections::HashSet



## VecDeque

<cb>VecDeque\<<v>Type<>, <v>Allocator<>><>

Type:

<cb>std::collections::VecDeque<>

Double Ended Queue


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/collections/index.html">collections<>::<l https://doc.rust-lang.org/std/collections/struct.VecDeque.html>VecDeque<>
@
@ vecdeque-only, vecdeques-only
@ double sided vec, double ended queue
@ std:collections::VecDeque



### VecDeque - Create


#### VecDeque - Create

<cb>= VecDeque::new()<>

Full Usage:

<cb>use std:collections::VecDeque;

let <v>vec_deque_1<>: VecDeque\<i32> = VecDeque::new();<>
@
@ VecDeque::new()
@ new, define, instantiate



#### VecDeque - Create Using Macro

<cb>= vec![]

= vec![<v>item_1<>, <v>item_2<>, <v>...<>]<>

Usage:

<cb>let <v>vec_1<>: Vec\<<v>i32<>> = vec![];

let <v>vec_1<> = vec![<v>item_1<>, <v>item_2<>, <v>...<>];<>

Returns:

<cb>VecDeque\<<v>type<>><>


Creates a vec.


Example:

<cb>let <v>vec_1<> = vec!["<v>a<>", "<v>b<>", "<v>c<>"];

for <v>item<> in <v>vec_1<>.iter() {
	print!("{} ", <v>item<>);
}
println!();

<#>// Prints: "a b c "<><>
@
@ vec!, vec![]
@ new, define, instantiate



### VecDeque - Operations


#### VecDecque - Push Front

<cb><v>vec_deque_1<>.push_front(<v>item<>);<>


Adds an item to the beginning of the queue.
@
@ vecdeque.push_front(), .push_front()



#### VecDecque - Push Back

<cb><v>vec_deque_1<>.push_back(<v>item<>);<>


Adds an item to the end of the queue.
@
@ vecdeque.push_back(), .push_back()



# Standard Types
@
@ std-only, std-type-only, std-types-only, std-struct-only, std-structs-only
@ standard-only, standard-type-only, standard-types-only, standard-struct-only, standard-structs-only


## Duration

<cb>std::time::Duration<>


Defines a duration in time.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/time/index.html">time<>::<l "https://doc.rust-lang.org/std/time/struct.Duration.html">Duration<>
@
@ std::time::Duration



### Duration - Create


#### Duration - Create in Milliseconds

<cb>= Duration::from_millis(<v>milliseconds_u64<>)<>

Usage:

<cb>use std::time::Duration

= Duration::from_millis(<v>milliseconds_int<>)<>
@
@ integer, u64
@ Duration::from_millis(), from_millis()



#### Duration - Create in Nanoseconds

<cb>= Duration::from_nanos(<v>nanoseconds_u64<>)<>

Usage:

<cb>use std::time::Duration

= Duration::from_nanos(<v>nanoseconds_int<>)<>
@
@ integer, u64
@ Duration::from_nanos(), from_nanos()



#### Duration - Create in Seconds

<cb>= Duration::from_secs(<v>seconds_u64<>)
= Duration::from_secs_f32(<v>seconds_f32<>)
= Duration::from_secs_f64(<v>seconds_f64<>)<>

Usage:

<cb>use std::time::Duration

= Duration::from_secs(<v>seconds_int<>)<>
@
@ integer, float, f32, f64, u64
@ Duration::from_secs(), Duration::from_secs_f32(), Duration::from_secs_f64()
@ from_secs(), from_secs_f32(), from_secs_f64()



### Duration - Properties


#### Duration - In Milliseconds

<cb>= <v>duration_1<>.as_millis()<>

Returns:

<cb>u64<>
@
@ to, convert, conversion
@ duration.as_millis(), .as_millis(), duration.as_milliseconds(), .as_milliseconds()



#### Duration - In Seconds

<cb>= <v>duration_1<>.as_secs()<>

Returns:

<cb>u64<>
@
@ to, convert, conversion
@ duration.as_secs(), .as_secs(), duration.as_seconds(), .as_seconds()



## SystemTime

<cb>std::time::SystemTime<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/time/index.html">time<>::<l "https://doc.rust-lang.org/std/time/struct.SystemTime.html">SystemTime<>
@ 
@ std::time::SystemTime, system time



### SystemTime - Create
@
@ new, instantiate


#### SystemTime - Now

<cb>= SystemTime::now()<>

Usage:

<cb>use std::time::SystemTime;

= SystemTime::now()<>

Returns:

<cb>SystemTime<>


Returns the current system time.
@
@ now, today
@ systemtime::now(), now()



#### SystemTime - Epoch

<cb>= SystemTime::UNIX_EPOCH<>

Usage:

<cb>use std::time::SystemTime;

= SystemTime::UNIX_EPOCH<>

Returns:

<cb>SystemTime<>


Returns the current system time.
@
@ original epoch time
@ systemtime::UNIX_EPOCH, UNIX_EPOCH



### SystemTime - Operations
@
@ops


#### SystemTime - Compare

<cb>= <v>system_time_1<> == <v>system_time_2<>

= <v>system_time_1<> \< <v>system_time_2<><>


All comparison operators work with SystemTime.


<in><table><col><c><v>a<> == <v>b<><>     <><col>Equals<>
<col><c><v>a<> != <v>b<><><><col>Not Equals<>
<col><c><v>a<> > <v>b<><><><col>Greater Than<>
<col><c><v>a<> \< <v>b<><><><col>Less Than<>
<col><c><v>a<> >= <v>b<><><><col>Greater Than or Equals<>
<col><c><v>a<> \<= <v>b<><><><col>Less Than or Equals<><><>
@
@ Boolean, ==, !=, \<>, \<, \<=, >, >/
@ less than, greater than, less that or equal, greater than or equal, comparison



#### SystemTime - Duration

<cb>= <v>systemtime_1<>.duration_since(<v>systemtime_2<>)<>

Returns:

<cb>Result\<Duration, SystemTimeError><>


Returns the duration between two system times.
@
@ systemtime.duration_since(), .duration_since()
@ between systemtimes, system times




#### SystemTime - Duration from Epoch

<cb>= <v>systemtime_1<>.duration_since(SystemTime::UNIX_EPOCH)<>

Returns:

<cb>Result\<Duration, SystemTimeError><>


Returns the duration from the Unix epoch (January 1st, 1970 at 00:00:00 UTC) and the system time.


Example:

<cb>use std::time::SystemTime;

let <v>now<> = SystemTime::now();

let <v>since_epoch<> = <v>now<>.duration_since(SystemTime::UNIX_EPOCH).unwrap();

println!("Time Since Epoch: {} secs", <v>since_epoch<>.as_secs());<>
@
@ systemtime.duration_since(), .duration_since()
@ between
@ systemtime::UNIX_EPOCH, UNIX_EPOCH



# Standard Wrapper Types
@
@ wrapper-only, wrappers-only


## Box

<cb>= Box::new(<v>value<>)<>

<cb>let <v>box_1<>: Box\<<v>T<>> = Box::new(<v>value<>);<>

Type:

<cb>Box\<<v>T<>><>


A box is a pointer to memory on the heap that has only one owner.

Creating a box creates data on the heap.


Example:

<cb>let <v>box_1<> = Box::new(<v>42<>_i32);

println!("{}", <v>box_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/boxed/index.html">boxed<>::<l https://doc.rust-lang.org/std/boxed/struct.Box.html>Box<>
@
@ Box::new(), Box\<T>, std::boxed::box, boxed:box
@ box-only, boxed, smart-pointer, smart pointer



### Box - Get Value

<cb>= *<v>boxed_item<>

= &*<v>boxed_item<><>


Dereferences the value stored in the boxed item.

Use <c>&*<> to borrow (reference) the dereferenced value.



## Cow

<cb>= <>

Type:

<cb>std::borrow::Cow<>

Definition:

<cb>pub enum Cow\<'a, B>
		where B: 'a + ToOwned + ?Sized, {
	Borrowed(&'a B),
	Owned(\<B as ToOwned>::Owned),
}<>


A smart pointer that allows a function to return either unchanged data (reuse) or new data (create). Allows the function to decided at runtime.

Allows the reuse (return) of data passed to the function if the function does not modify it. The function will return it as <c>Borrowed<>.
Also allows the function to return new data if required. The function will new data as <c>Owned<>.

Returned data type must allow <c>clone()<>.


COW = Clone on Write

Rust Docs: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/borrow/index.html">borrow<>::<l "https://doc.rust-lang.org/stable/std/borrow/enum.Cow.html">Cow<>
@
@ std::borrow::Cow, borrow::cow
@ cow-only, smart pointer, smart-pointer



## Rc

<cb>= Rc::new(<v>value<>)<>

<cb>use std::rc::Rc;

let <v>rc_1<>: Rc\<<v>T<>> = Rc::new(<v>value<>);<>

Type:

<cb>std::rc::Rc\<<v>T<>><>


An RC is a pointer to memory on the heap that can have multiple owners.

RC = Reference Counted

Creating rc creates data on the heap.
Rc is not thread safe.



Example:

<cb>use std::rc::Rc;

let <v>rc_1<> = Rc::new(<v>42<>_i32);

println!("{}", <v>rc_1<>);

<#>// Prints: "42"<><>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/rc/index.html">rc<>::<l https://doc.rust-lang.org/std/rc/struct.Rc.html>Rc<>
@
@ Rc::new(), Rc\<T>, std::rc::rc, rc:rc
@ rc-only



# Standard Traits
@
@ standard-traits-only, system-traits-only, std-traits-only, sys-traits-only



## Trait - Clone

<cb>trait Clone {
	fn clone(&<v>self<>) -> Self;
	fn clone_from(&mut <v>self<>, <v>source<>: &Self) { <v>...<> }
}<>


Creates a copy of an item.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l https://doc.rust-lang.org/std/clone/index.html>clone<>::<l https://doc.rust-lang.org/std/clone/trait.Clone.html>Clone<>
@
@ std::clone::Clone
@ .clone(), .clone_from()



## Trait - Debug

<cb>pub trait Debug {
	fn fmt(&self, f: &mut Formatter\<'_>) -> Result\<(), Error>;
}<>

Type:

<cb>std::fmt::Debug<>


Prints a programmer readable representation of the item.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fmt/index.html">fmt<>::<l "https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug<>
@
@ fmt(), std::fmt::Debug



## Trait - Default

<cb>pub trait Default {
	fn default() -> Self;
}<>

Type:

<cb>std::default::Default<>


Creates an instance with basic default values.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/default/index.html">default<>::<l "https://doc.rust-lang.org/std/default/trait.Default.html">Default<>
@
@ fmt(), std::fmt::Debug



## Trait - Display

<cb>pub trait Display {
	fn fmt(&self, f: &mut Formatter\<'_>) -> Result\<(), Error>;
}<>

Usage:

<cb>use std::fmt::Display;

impl Display for <v>Struct1<> {

	fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
		write!(f, "<v>...<>", <v>...<>)
	}
}<>

Type:

<cb>std::fmt::Display<>


Prints a human readable representation of the item.

Automatically implements the <c>ToString<> trait.


Example:

<cb>use std::fmt::Display;

struct Point {
	<v>x<>: i32,
	<v>y<>: i32
}

impl Display for Point {

	fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
		write!(f, "{}, {}", self.<v>x<>, self.<v>y<>)
	}
}

fn main() {

	let <v>point<> = Point {<v>x<>: 3, <v>y<>: 4};
	println!("Point: {}", <v>point<>);
}<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/fmt/index.html">fmt<>::<l "https://doc.rust-lang.org/std/fmt/trait.Display.html">Display<>
@
@ fmt(), tostring, .to_string(), std::fmt::Display




## Trait - Drop (destructor)

<cb>trait Drop {
	fn drop(&mut self);
}<>

Type:

<cb>std::ops::Drop<>


The <c>drop()<> is called automatically when the object goes out of scope.

Use this to implement a destructor on a type.
This <b>must not<> fail.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/ops/index.html">ops<>::<l "https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop<>
@
@ drop(), destructor, std::ops::Drop



## Trait - Error

<cb>pub trait Error: Debug + Display {
	fn source(&self) -> Option\<&(dyn Error + 'static)>;
	fn backtrace(&self) -> Option\<&Backtrace>;
}<>

Type:

<cb>std::error::Error<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/error/index.html">error<>::<l "https://doc.rust-lang.org/std/error/trait.Error.html">Error<>
@
@ error-only, std::error::Error



### Error - Properties


#### Error - Get Backtrace

<cb>= <v>error<>.backtrace()<>

Returns:

<cb>Option\<&Backtrace><>


Returns the back trace if available.
@
@ call stack, back trace
@ error.backtrace(), .backtrace()



#### Error - Get Source

<cb>= <v>error<>.source()<>

Returns:

<cb>Option\<&(dyn Error + 'static)><>


Returns the original error if any.
@
@ call stack
@ error.source(), .source()



#### Error - To String

<cb>= <v>error<>.to_string()<>
@
@ error.to_string(), .to_string()



## Trait - From

<cb>pub trait From\<<v>T<>> {
	fn from(<v>T<>) -> Self;
}<>

Type:

<cb>std::convert::From<>


Converts an item from one type into another.

Automatically implements the <c>Into<> trait.
This <b>must not<> fail.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/convert/index.html">convert<>::<l "https://doc.rust-lang.org/std/convert/trait.From.html">From<>
@
@ Convert, conversion, from, to
@ std::convert::From, from()



## Trait - Into

<cb>pub trait Into\<<v>T<>> {
	fn into(<v>self<>) -> T;
}<>

Type:

<cb>std::convert::Into<>


Converts an item from one type into another.

Automatically implements the <c>Into<> trait.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/convert/index.html">convert<>::<l "https://doc.rust-lang.org/std/convert/trait.Into.html">Into<>
@
@ Convert, conversion, from, to
@ std::convert::Into, into()



## Trait - Iterator

<cb>pub trait Iterator {
	type Item;

	fn next(&mut self) -> Option<Self::Item>;
	fn count(self) -> usize { ... }
	<v>...<>
}<>

Type:

<cb>std::iter::Iterator<>

Provides the functions used by iterators such as <c>Vec<>.iter()<>.

Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/iter/index.html">iter<>::<l "https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator<>
@
@ .iter(), iterator-only, iterators-only, iter-only, iters-only



### Iterator - Functions
@
@ function, 


#### Iterator - All

<cb>= <v>iterator_1<>.all(<v>test_function<>)<>

Returns: bool


Returns true if every item in the iterator returns true from the test function.
@
@ item, element, value
@ iter().all(), .all()



#### Iterator - Any

<cb>= <v>iterator_1<>.any(<v>test_function<>)<>

Returns: bool


Returns true if a single item in the iterator returns true from the test function.
@
@ item, element, value
@ iter().any(), .any()


	
#### Iterator - Collect

<cb>= <v>iterator_1<>.collect()

= <v>iterator_1<>.collect()::\<Vec\<<v>T<>>><>

Returns:

<cb>Vec\<<v>T<>><>


Turns an iterator into a collection of values.
@
@ to into
@ iterator.collect(), iter.collect(), .collect(), vec, sequence
@ turbofish, ::\<>



#### Iterator - Count

<cb>= <v>iterator_1<>.count()<>

Returns:

<cb>usize<>


Returns the number of elements in the iterator.
@
@ items, elements, values
@ iter().count(), .count()



#### Iterator - Find

<cb>= <v>iterator_1<>.find(<v>match_function<>)><>

Returns:

<cb>Optional:\<T><>


Returns the item that returns true for the match function.
@
@ item, element, value
@ iter().find(), .find()



#### Iterator - First

<cb>= <v>iterator_1<>.next()<>

Returns:

<cb>Optional\<T><>


Use <c>.next()<> to get the first item from an iterator.
@
@ item, element, value, get, find
@ iter().first(), .first(), 1st



#### Iterator - Fold

<cb>= <v>iterator_1<>.fold(<v>fold_function<>)<>

Returns: Result Type

Fold Function:

<cb>|<v>result<>, <v>item<>| -> <v>result<><>


Folds the iterator values down to one value.

All values are passed into the fold function along with the result from the previous calculation.
The final result is returned.
@
@ items, elements, values, get, to single value, to 1 one result
@ iter().fold(), .fold()



#### Iterator - Last

<cb>= <v>iterator_1<>.last()<>

Returns:

<cb>Optional\<T><>


Returns the last item from the iterator.
@
@ item, element, value
@ iter().last(), .last()



#### Iterator - Min

<cb>= <v>iterator_1<>.min()<>

Returns:

<cb>Optional\<T><>


Returns the minimum value from the iterator.
@
@ minimum, value
@ iter().min(), .min()



#### Iterator - Max

<cb>= <v>iterator_1<>.max()<>

Returns:

<cb>Optional\<T><>


Returns the maximum value from the iterator.
@
@ maximum, value
@ iter().max(), .max()



#### Iterator - Next

<cb>= <v>iterator_1<>.next()<>

Returns:

<cb>Optional\<T><>


Returns the next item from the iterator.
@
@ item, element, value
@ iter().next(), .next()



#### Iterator - Nth

<cb>= <v>iterator_1<>.nth(<v>index<>)<>

Returns:

<cb>Optional\<T><>


Returns the nth element from the iterator.
@
@ item, element, value
@ iter().nth(), .nth()



#### Iterator - Position

<cb>= <v>iterator_1<>.position(<v>match_function<>)<>

Returns:

<cb>Optional\<T><>


Returns the position where the match function returns true.
@
@ item, element, value
@ iter().position(), .position(), index, find



#### Iterator - Sum

<cb>= <v>iterator_1<>.sum()<>
@
@ all items, elements, values
@ iter().sum(), .sum()



### Iterator - Transformation Functions

These are functions that return a new iterator.


#### Iterator - Chain

<cb>= <v>iterator_1<>.chain(<v>iterator_2<>)

= <v>iterator_1<>.chain(<v>sequence_2<>.iter())<>


Combines to iterators together.

Use to chain two or more sequences together.
@
@ iterator.chain(), iter.chain(), .chain()



#### Iterator - Enumerate

<cb>= <v>iterator_1<>.enumerate()<>

Returns:

<cb>Iterator\<(usize, T)><>


Enumerates all element within the iterator.
@
@ iterator.enumerate(), iter.enumerate(), .enumerate()



#### Iterator - Filter

<cb>= <v>iterator_1<>.filter(<v>match_function<>)<>


Returns a new iterator for all item where the match function is true.
@
@ iterator.filter(), iter.filter(), .filter()



#### Iterator - Flatten

<cb>= <v>iterator_1<>.flatten()<>


Flattens all iterator values in the top level and one level down.
@
@ iterator.flatten(), iter.flatten(), .flatten()



#### Iterator - Map

<cb>= <v>iterator_1<>.map(<v>mapping_function<>)<>


Maps (converts) the iterator values into new values using the mapping function.
@
@ iterator.map(), iter.map(), .map()
@ convert, conversion



#### Iterator - Rev

<cb>= <v>iterator_1<>.rev()<>


Reverses the items in the iterator.
@
@ iterator.rev(), iter.rev(), .rev()




#### Iterator - Skip

<cb>= <v>iterator_1<>.skip(<v>match_function<>)<>


Skips all iterator values that return true from the match function.
@
@ iterator.skip(), iter.skip(), .skip()




#### Iterator - Zip

<cb>= <v>iterator_1<>.zip(<v>other<>.iter())<>


Zips together (pairs up) the values from two iterators.

Creates zipped tuples.
The new iterator will have the same number of elements as the shortest list.
@
@ iterator.zip(), iter.zip(), .zip()



## Trait - ToOwned

<cb>pub trait ToOwned {
    type Owned: Borrow\<Self>;

    fn to_owned(&self) -> Self::Owned;
    fn clone_into(&self, target: &mut Self::Owned) { <v>...<> }
}<>

Type:

<cb>std::borrow::ToOwned<>


Converts borrowed data into owned data.

Ownership is created by cloning the data (creating a new copy).


Rust Docs: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/borrow/index.html">borrow<>::<l "https://doc.rust-lang.org/stable/std/borrow/trait.ToOwned.html">ToOwned<>
@
@ .to_owned(), .clone_into()
@ std::borrow::ToOwned, toowned-only



## Trait - ToString

<cb>pub trait ToString {
	fn to_string(&self) -> String;
}<>

Type:

<cb>std::string::ToString<>


Prints a human readable representation of the item.

This is automatically created for items with the <c>Display<> trait.


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/string/index.html">string<>::<l "https://doc.rust-lang.org/std/string/trait.ToString.html">ToString<>
@
@ .to_string(), tostring, tostring-only
@ std::string::tostring, string::tostring



# Syncronized Library

Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/sync/index.html">sync<>
@
@ sync-only, synchronized-only


## Mutex

Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/sync/index.html">sync<>::<l "https://doc.rust-lang.org/std/sync/struct.Mutex.html">Mutex<>



# Environment Variables
@
@ environment-only, environment-variables-only, env-var-only


### Environment Variable - Get

<cb>= var("<v>name<>")<>

Usage:

<cb>use std::env::var;

= var("<v>name<>")<>

returns:

<cb>Result\<String, VarError><>


Returns an environment variable.

Returns an error if the variable doesn't exist.


Example:

<cb>use std::env::var;

let <v>home<> = var("HOME").unwrap();

println!("HOME: {}", <v>home<>);<>



Rust Docs: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/env/index.html">env<>::<l "https://doc.rust-lang.org/std/env/fn.var.html">var<>
@
@ std::env::var, std::env::var(), env::var(), var()



### Environment Variables - Get Names

<cb>= std::env::vars().map(|(<v>name<>, _)| <v>name<>).collect();<>

Usage:

<cb>use std::env::vars;

let <v>names<>: Vec\<String> = vars().map(|(<v>name<>, _)| <v>name<>).collect();<>

returns:

<cb>Vec\<String><>


Returns all environment variable names.


Example:

<cb>use std::env::vars;

let mut <v>names<>: Vec<String> = vars().map(|(<v>name<>, _)| <v>name<>).collect();
<v>names<>.sort();

for <v>name<> in <v>names<> {
	println!("{}", <v>name<>);
}<>


Rust Docs: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/env/index.html">env<>::<l "https://doc.rust-lang.org/std/env/fn.vars.html">vars<>
Rust Docs: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/env/index.html">env<>::<l "https://doc.rust-lang.org/std/env/struct.Vars.html">Vars<>
@
@ std::env::var, std::env::var(), env::var(), var(), names, keys



### Environment Variables - Get Name Values

<cb>= vars()<>

Usage:

<cb>use std::env::vars;

= vars()<>

returns:

<cb>Vars<>


Returns all environment variables as name value pairs.


Example:

<cb>use std::env::vars;

for (<v>name<>, <v>value<>) in vars() {
	println!("{<v>name<>:40}:  {<v>value<>}");
}<>


Rust Docs: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/env/index.html">env<>::<l "https://doc.rust-lang.org/std/env/fn.vars.html">vars<>
Rust Docs: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/env/index.html">env<>::<l "https://doc.rust-lang.org/std/env/struct.Vars.html">Vars<>
@
@ std::env::var, std::env::var(), env::var(), var(), names, keys, values



# Testing
@
@ unit tests
@ tests-only, testing-only, unit-test-only, unit-testing-only


## Test Basics

Test Folder:

<cb><v>project<>
‚îî‚îÄ‚îÄ tests
	‚îî‚îÄ‚îÄ <v>*.rs<><>

Test:

<cb>#[cfg(test)]
mod test {

	#[test]
	fn <v>basic_test<>() {
		assert!(<v>expression<>, "<v>Fail message.<>");
	}

	#[test]
	#[should_panic(expected = "<v>No panic error message.<>")]
	fn test_panic() {
		<v>...<>
	}
}<>

Assertions:

<cb>assert!(<v>expression<>);
assert!(<v>expression<>, "<v>message<>");

assert_eq!(<v>actual<>, <v>expected<>);
assert_eq!(<v>actual<>, <v>expected<>, "<v>message<>");

assert_ne!(<v>actual<>, <v>not_expected<>);
assert_ne!(<v>actual<>, <v>not_expected<>, "<v>message<>");<>



## Test - Definition
@
@ new, create


### Test - Define Test Module

<cb>#[cfg(test)]
mod test {

	<v>...<>
}<>



### Test - Define Test Function

<cb>#[test]
fn <v>basic_test<>() {
	<v>...<>
}<>

Usage:

<cb>#[cfg(test)]
mod test {

	#[test]
	fn <v>basic_test<>() {

		<#>Assertions Here<>

		assert(<v>expression<>, "<v>Fail message.<>");
	}
}<>
@
@ #[test]



### Test - Define Test Function - Test Panic

<cb>#[should_panic]
fn <v>panic_test<>() {
	<v>...<>
}<>

<cb>#[should_panic(expected = "<v>No panic error message.<>")]
fn <v>panic_test<>() {
	<v>...<>
}<>

Usage:

<cb>#[cfg(test)]
mod test {

	#[test]
	#[should_panic]
	fn <v>panic_test<>() {
		<v>...<>
	}
}<>
@
@ #[test], #[should_panic], errors, panics




## Test - Assertions
@
@ assert macros


### Test Assertion

<cb>assert!(<v>expression<>);<>

Usage:

<cb>#[test]
fn <v>assert_test<>() {
	assert!(<v>expression<>);
}<>


Passes when the expression returns true
@
@ assert!(), is true



### Test Assertion - Equals

<cb>assert_eq!(<v>actual<>, <v>expected<>);<>

Usage:

<cb>#[test]
fn <v>assert_test<>() {
	assert_eq!(<v>actual<>, <v>expected<>);
}<>


Passes when actual equals expected.
@
@ assert_eq!(), is equal



### Test Assertion - Not Equals

<cb>assert_ne!(<v>actual<>, <v>not_expected<>);<>

Usage:

<cb>#[test]
fn <v>assert_test<>() {
	assert_ne!(<v>actual<>, <v>not_expected<>);
}<>


Passes when actual not equals expected.
@
@ assert_ne!()



# How To
@
@ how-to


### Command - Execute

<cb>cmd!(<v>command<> <v>param1<> <v>param2<> <v>...<>)<>

Equivalent To:

<cb>let <v>command1<> = std::process::Command::new("<v>command<>");
<v>command<>.arg("<v>param1<>");
<v>command<>.arg("<v>param2<>");<>

The <c>cmd!<> command and parameters do not require quotes around the names (<m>confirm<>).
@
@ cmd!, std::process::Command:



### Command Line Arguments - Get

<cb>= env::args().collect()<>

Full Form:

<cb>use std::env;

let <v>args<>: Vec\<String> = env::args().collect();<>

Returns:

<cb>Vec\<String><>


Example:

<cb>use std::env;

fn main() {

	let <v>args<>: Vec\<String> = env::args().collect();

	let <v>command<> = &<v>args<>[0];
	let <v>first<> = &<v>args<>[1];

	println!("All:     {:?}", <v>args<>);
	println!("Command: {}", <v>command<>);
	println!("First:   {}", <v>first<>);
}<>
@
@ parameters, params, args
@ std::env::args(), env::args(), args(), args().collect()



### Compile - Small Code

cargo.toml:

<cb>[profile.release]
strip = true		<#># Strips symbols<>
opt-level = "s"		<#># Optimize for size<>
lto = true			<#># Enable Link Time Optimization<>
codegen-units = 1	<#># Minimizes Size By Reducing Parallel Build Processes<><>


Compile:

<cb>cargo --release<>
@
@ command, cargo, --release



### Current Working Directory - Get

<cb>= current_dir()<>

Usage:

<cb>use std::env::current_dir;

= current_dir()<>

Returns:

<cb>Result\<PathBuf><>


Returns the current directory.


Example:

<cb>use std::env::current_dir;
use std::path::PathBuf;

let <v>path<>: PathBuf = current_dir().unwrap();
let <v>directory<> = <v>path<>.to_str().unwrap();

println!("Current Directory: {}", &<v>directory<>);<>


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/env/index.html">env<>::<l "https://doc.rust-lang.org/std/env/fn.current_dir.html">current_dir<>
Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/path/index.html">path<>::<l "https://doc.rust-lang.org/std/path/struct.PathBuf.html">PathBuf<>
@
@ pwd, cwd, path
@ std::env::current_dir(), env::current_dir(), current_dir()



### Input - Read

<cb>= stdin().read_line(&mut <v>value<>)<>

Usage:

<cb>use std::io::stdin;

let mut <v>value<> = String::new();

match stdin().read_line(&mut <v>value<>) {
	Ok(_) => {
		<v>value<>.pop();  <#>// Removes the \\n at the end the input.<>
		<v>value<>
	}

	Err(<v>error<>) => {
		<v>...<>
	}
}<>

Returns:

<cb>Result\<usize><>


Reads from the standard input into <c>value<>.

Returns the number of bytes read.
Includes the <c>\\n<> used to complete the input.


Rust Docs: <l "https://doc.rust-lang.org/stable/std/index.html">std<>::<l "https://doc.rust-lang.org/stable/std/io/index.html">io<>::<l "https://doc.rust-lang.org/stable/std/io/struct.Stdin.html">Stdin<>.<l "https://doc.rust-lang.org/stable/std/io/struct.Stdin.html#method.read_line">read_line<>
@
@ std::io::stdin(), io::stdin(), stdin(), stdin().read_line(), .read_line()



### Print!

<cb>print!("Print this.");<>

<cb>print!("Values {} and {}.", <v>a<>, <v>b<>);<>


Prints to the standard out.
No newline is sent.


Example:

<cb>for <v>value<> in 0..=3 {
	print!("{} ", <v>value<>);
}
println!();

<#>// Prints: "0 1 2 3 "<><>
@
@ print, print!(), no newline, macros



### Print! - Stay on Line

<cb>print!("Print and stay on line.\\r");<>

<cb>print!("{}\r", <v>value<>);<>

Usage:

<cb>use std::io::stdout;
use std::io::Write;

print!("{}\\r", <v>value<>);
stdout().flush().unwrap();<>


Prints to the standard out.
No newline is sent.

Requires the <c>.flush()<> to submit the print.
Using <c>std::io::Write<> brings in the <c>flush()<> trait.


Example:

<cb>for <v>value<> in 0..=3 {
	print!("{} ", <v>value<>);
}
println!();

<#>// Prints: "0 1 2 3 "<><>
@
@ print, print!(), no newline, macros, stdio().flush(), .flush()



### Println!

<cb>println!()<>

<cb>println!("Print this.");<>

<cb>println!("Values {} and {}.", <v>a<>, <v>b<>);<>


Prints a line followed by newline to the standard out.


Examples:

Print Empty Line:

<cb>println!()<>

Print Variable Value:

<cb>let <v>name<> = "<v>your_name_here<>";

println!("My name is {}.", <v>name<>);

<#>// Prints "My name is your_name_here".<><>
@
@ println!(), printline, macros



### Println! - Debug String

<cb>println!("{:?}", <v>value<>);<>


Prints the debug string for a value.


Must implement:

<cb>#[derive(Debug)]<>
@
@ #[derive(Debug)], derive, :?, {:?}, macros



### Sleep

<cb>sleep(<v>duration<>);<>

<cb>use std::thread::sleep;
use std::time::Duration;

let <v>sleep_duration<> = Duration::from_millis(<v>time_in_milliseconds<>);

sleep(<v>sleep_duration<>);<>


Suspends the current thread for the time defined in the duration.
@
@ std::thread::sleep, sleep()



### System - Exit, Return Exit Code

<cb>exit(<v>exit_code<>);<>

Usage:

<cb>use std::process::exit;

exit(<v>exit_code<>);<>


Returns from execution with the given exit code.


Recommended Exit Codes:

	0	OK
	1	General Error
	2	Command-line Validation


Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::<l "https://doc.rust-lang.org/std/process/index.html">process<>::<l "https://doc.rust-lang.org/std/process/fn.exit.html">exit<>
@
@ error code, status, number, end program, stop, quit, .exit(), .exit(), .quit(), application, program
@ std::process::exit(), process::exit(), exit()




# Naming Conventions
@
@ Names, naming-conventions-only, conventions-only


## Naming Conventions - Basics

<table><col>Constant<><col><c><v>UPPER_SNAKE_CASE<><><>
<col> <>
<col>Constructor - General<><col>new

<c>with_<v>more_details<><><>
<col> <>
<col>Constructor - Conversion<><col><c>from_<v>some_other_type<><><>
<col> <>
<col>Crate<><col>No Convention?<>
<col> <>
<col>Enum Variant<><col><c><v>TitleCase<><><>
<col> <>
<col>Feature<><col>No Convention?<>
<col> <>
<col>Function<><col><c><v>snake_case<><><>
<col> <>
<col>Lifetime<><col><c><v>lowercase<><><>
<col> <>
<col>Method<><col><c><v>snake_case<><><>
<col> <>
<col>Macro<><col><c><v>snake_case<>!<><>
<col> <>
<col>Module<><col><c><v>snake_case<><><>
<col> <>
<col>Static<><col><c><v>UPPER_SNAKE_CASE<><><>
<col> <>
<col>Trait<><col><c><v>TitleCase<><><>
<col> <>
<col>Type<><col><c><v>TitleCase<><><>
<col> <>
<col>Type Parameter<><col><c><v>T<><>  (Upper Case Letter)

<c><v>TitleCase<><><>
<col> <>
<col>Variable<><col><c><v>snake_case<><><>
<col> <>
<col>Variable - Constants<><col><c><v>UPPER_SNAKE_CASE<><><>
<col> <>
<col>Variable - Unused<><col><c><v>_leading_underscore<><><><>

See:
<l>https://rust-lang.github.io/api-guidelines/naming.html<>



## Naming Convention Details


### Convention - Constants

<cb><v>UPPER_SNAKE_CASE<><>


### Convention - Constructors - General

<cb>new<>

<cb>with_<v>more_details<><>


### Convention - Constructors - Conversion

<cb>from_<v>some_other_type<><>


### Convention - Crates

No convention?


### Convention - Modules

<cb><v>snake_case<><>


### Convention - Enum Variants

<cb><v>TitleCase<><>


### Convention - Features

No convention?

<m>See: C-FEATURE
<l>https://rust-lang.github.io/api-guidelines/naming.html#c-feature<><>


### Convention - Functions

<cb><v>snake_case<><>


### Convention - Lifetimes

<cb>lowercase<>

Use short words.
Some recommend a single letter but I strongly disagree.


### Convention - Macros

<cb><v>snake_case<>!<>


### Convention - Methods

<cb><v>snake_case<><>


### Convention - Statics

<cb><v>UPPER_SNAKE_CASE<><>


### Convention - Traits

<cb><v>TitleCase<><>


### Convention - Types

<cb><v>TitleCase<><>


### Convention - Type Parameters

<cb><v>TitleCase<><>

<cb><v>T<><>

Short concise name in TitleCase.
Some recommend a single uppercase letter.


### Convention - Variables

<cb><v>snake_case<><>


### Convention - Variables - Constants

<cb><v>UPPER_SNAKE_CASE<><>



### Convention - Variables - Unused

<cb><v>_leading_underscore<><>

The compiler will ignore unused variables when they have a leading underscore.



# Reference - Directories


## Linux / Mac


### Linux / Mac - User Cargo Directory

<cb>$HOME/.cargo<>

Cargo's user root directory.


### Linux / Mac - User Cargo Bin Directory

<cb>$HOME/.cargo/bin<>

Contains Cargo commands such as:

<indent><c>cargo, rustc, rustup<><>
@
@ .cargo/bin, bin


### Linux / Mac - User Cargo Environment Directory

<cb>$HOME/.cargo/env<>
@
@ .cargo/env, env


### Linux / Mac - User Rustup Directory

<cb>$HOME/.rustup<>

Contains metadata, toolchains.

Configure to this directory with <c>RUSTUP_HOME<>
@
@ .rustup



# Reference - Symbols

Official Rust Docs: <l https://doc.rust-lang.org/book/appendix-02-operators.html>Operator Appendix<>
@
@ symbols-only


### Symbol ;

Command Terminator

<cb>println!("This is terminated by a semicolon");<>
@
@ semicolon



### Symbol ;

Array Type Size Separator

<cb>let <v>array_1<>: [<v>T<>; <v>size<>] = <v>...<>;<>
@
@ semicolon



### Symbol .

Dot Operator

The dot operator indentifies the next item as an instance field or method.
@
@ dot operator



### Symbol ..

Iterator

Returns values starting with the minimum value to up to the value before the end value.

<cb>= <v>start<>..<v>end_plus_one<><>
@
@ dot operator



### Symbol ..

Struct Copy Operator

Creates a copy of a struct item.

<cb>= <v>Struct1<> { ..<v>item1<> }<>
@
@ dot operator, struct



### Symbol ..=

Iterator

Returns values starting with the starting value to up to and including the end value.

<cb>= <v>start<>..=<v>end<><>
@
@ dot operator



### Symbol ::

Namespace Path Separator

<cb><v>std<>::<v>vec<>::<v>Vec<><>

Associative Function (static method) Accessor:

<cb><v>Type<>::<v>function<>()<>
@
@ double colon



### Symbol :?

Return Debug String (Format)

<cb>println!("{:?}", <v>value<>);<>
@
@ {:?}



### Symbol '

Defines Loop Name

<cb>'<v>loop_name<> {
	<v>...<>
	break <v>loop_name<>;
}<>



### Symbol 'static

Defines the lifetime of a variable to the lifetime of the program.

Official Rust Docs: <l "https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html">Static Lifetime<>



### Symbol *

Dereference 

Dereferences a reference (pointer).
Points to actual data.

<cb>= *<v>a<><>



### Symbol *const

Raw Pointer (Unsafe)

<cb>let *const <v>a<>;<>



### Symbol *mut

Raw Mutable Pointer (Unsafe)

<cb>let *mut <v>a<>;<>



### Symbol !

Bitwise Complement / Inverse Operator

<cb>= !<v>value<><>



### Symbol !

A Rust Macro

<cb><v>macro<>!();

= <v>macro<>!()<>



### Symbol &

Reference (pointer) to a Memory Location


Examples:

New reference to a variable:

<cb>let <v>a<> = &<v>b<>;<>

Pointer parameter to outside variable:

<cb>fn print(<v>value<>: &str) {
	<v>...<>
}<>
@
@ pointer



### Symbol &

Borrow Resource

<cb>= &<v>variable_1<><><>


Examples:

<cb>let <v>owner<> = "42".to_string();

let <v>borrower<> = &<v>owner<>;

println!("{}", &<v>owner<>);
println!("{}", <v>borrower<>);

<#>// Prints:
//
//    "42"
//    "42"<><>



### Symbol &

Bitwise And

<cb>= <v>a<> & <v>b<><><>


Example:

<cb>let <v>a<> = 0b1100;
let <v>b<> = 0b0101;

let <v>bitwise_and<> = <v>a<> & <v>b<>;

println!("Bitwise And = {:b}.", <v>bitwise_and<>);

<#>// Prints "Bitwise And = 100"<><>
@
@ binary



### Symbol &&

Logical And Operator

<cb>= <v>a<> && <v>b<><><>


Example:

<cb>let <v>a<> = true;
let <v>b<> = false;

let <v>logical_and<> = <v>a<> && <v>b<>;

println!("Locigal And = {}", <v>logical_and<>);

<#>// Prints "Locigal And = false"<><>
@
@ double ampersand



### Symbol &mut

Reference (pointer) to a Mutable Memory Location

<cb>let <v>a<>: &mut:i32 = 42;<>
@
@ pointer



### Symbol &mut

Borrow a Mutable Resource with Intent to Change It

<cb>= &mut <v>variable_1<><><>



### Symbol |

Bitwise Or

<cb>= <v>a<> | <v>b<><><>


Examples:

<cb>let <v>a<> = 0b1100;
let <v>b<> = 0b0101;

let <v>bitwise_or<> = <v>a<> | <v>b<>;

println!("Bitwise Or = {:b}.", <v>bitwise_or<>);

<#>// Prints "Bitwise Or = 1101"<><>
@
@ binary



### Symbol ||

A Logical Or Operator

<cb>= <v>a<> || <v>b<><><>

A Closure With No Parameters:

<cb>= || <v>...<><>

A Closure With A Parameter:

<cb>= |<v>param_1<>: <v>type<>| <v>...<><>


Examples:

Logical Or:

<cb>let <v>a<> = true;
let <v>b<> = false;

let <v>logical_or<> = <v>a<> || <v>b<>;

println!("Locigal Or = {}", <v>logical_or<>);

<#>// Prints "Locigal Or = true"<><>

Closure:

<cb>let <v>closure_1<> = || println!("This is a closure.");

<v>closure_1<>();

<#>// Prints "This is a closure."<><>
@
@ double pipe



### Symbol ^

Bitwise XOR

<cb>= <v>a<> ^ <v>b<><><>


Examples:

<cb>let <v>a<> = 0b1100;
let <v>b<> = 0b0101;

let <v>bitwise_xor<> = <v>a<> ^ <v>b<>;

println!("Bitwise XOR = {:b}.", <v>bitwise_xor<>);

<#>// Prints "Bitwise XOR = 1001"<><>
@
@ binary



### Symbol []

Defines an Array

<cb>let <v>array_1<>: [<v>Type<>, <v>size<>];<>

<cb>= [<v>value_1<>, <v>value_2<>, <v>value_3<>]<>



### Symbol []

Access an Array Element

<cb>= <v>array_1<>[0]<>



### Symbol ()

Tuple

<cb>= (<v>value_1<>, <v>value_2<>, <v>value_3<>)<>



### Symbol ()

Unit

<cb> = ()<>

The empty value returned by a function that does not return a value.
@
@ unit



### Symbol //

Comment.

<cb><#>/// this is a comment.<><>



### Symbol ///

Document Comment

<cb><#>/// Function document.<>
fn <v>function_1<>() {
	<v>...<>
}<>


### Symbol #[]

Attribute

Applies to item or module.

<cb>#[<v>...<>]<>


Example:

<cb>#[deprecated]<>
@
@ #[, ], hash square bracket



### Symbol #![]

Attribute

Applies to the entire crate.

<cb>#![<v>...<>]<>


Example:

<cb>#![allow(dead_code)]<>
@
@ #![, ], hash bang, Exclamation



### Symbol _

Identifies an intentionally unused variable.

<cb>let <v>_unused_variable<> = 0;<>
@
@ leading underscore



### Symbol ?

Question Mark Operator (Error Propagation Operator).

Propagates a <c>Result::Err<> error to the parent function.


<cb>fn <v>some_function<> -> Result\<T, E> {
	<v>some_subfunction<>()?;
}<>
@
@ question mark, propagation, error



# Memory

<*>Data Memory
Stack Memory
Heap Memory<>



### Memory - Data Memory
Used for data that is both static and fixed in size data.

Static - Data that is alive for the entire life of the application.

Example: String


### Memory - Stack Memory
Stores function variables.

Memory locations wouldn't change for the life of the function call.
The compiler optimizes this memory very efficiently.


### Memory - Heap Memory
For dynamically allocated memory, memory that may need to be moved, resized, added, deleted, etc.

This is the slowest and relatively most costly memory to use.


#### Heap Memory - Allocation
Allocating new data to the heap memory.


#### Heap Memory - Deallocation
Removing existing data from the heap memory.



### Memory - Where Is My Data Stored?

str:

<*>Stack
Heap
Application Binary<>


Primitives:
Structs with Primitives Only:

<*>Stack
(by default unless explicitly put on heap)<>


Size Known Only at Runtime (e.g. String, Vec):
Explicitly Placed on Heap (e.g. Box)

<*>Heap
(always dynamically allocatded)<>



# Reserved Words
@
@ reserved-words-only, reserved-only
@ keywords-only, keyword-only


### Reserved Words - Summary

A reserved word is a keyword that has special meaning or purpose to Rust.
It can not be used as the name of variable, function or anything else.

<in><table><col><c>abstract<>       <><col><s>(For Future Use)<><>
<col><c>as<><><col>Casts a Variable, or Renames a Item<>
<col><c>async<><><col>Returns a Future<>
<col><c>await<><><col>Suspend Execution Until Future Is Done<>
<col><c>become<><><col><s>(For Future Use)<><>
<col><c>box<><><col><s>(For Future Use)<><>
<col><c>break<><><col>Exits a Loop<>
<col><c>const<><><col>Defines a Constant<>
<col><c>continue<><><col>Continue to Next Loop Iteration<>
<col><c>crate<><><col>Links to an External Crate<>
<col><c>do<><><col><s>(For Future Use)<><>
<col><c>dyn<><><col>Dynamic Dispatch To Trait<>
<col><c>else<><><col>Conditional If Statement, Falback Clause<>
<col><c>enum<><><col>Defines an Enum<>
<col><c>extern<><><col>Link To an External Crate, Function, or Variable<>
<col><c>false<><><col>Boolean Literal<>
<col><c>final<><><col><s>(For Future Use)<><>
<col><c>fn<><><col>Defines a Function or Function Pointer<>
<col><c>for<><><col>For Loop, or Implements a Trait, or Specifiesa Higher-ranked Lifetime<>
<col><c>if<><><col>Conditional If Statement<>
<col><c>impl<><><col>Implement Inherent or Trait<>
<col><c>in<><><col>For Loop<>
<col><c>let<><><col>Create a Variable<>
<col><c>loop<><><col>Unconditional Loop<>
<col><c>macro<><><col><s>(For Future Use)<><>
<col><c>match<><><col>Match Control Statement<>
<col><c>mod<><><col>Defines a Module<>
<col><c>move<><><col>Gives Ownership To Closure<>
<col><c>mut<><><col>Mutable Value / Pointer<>
<col><c>override<><><col><s>(For Future Use)<><>
<col><c>priv<><><col><s>(For Future Use)<><>
<col><c>pub<><><col>Set Public Visibility<>
<col><c>ref<><><col>Reference Binding<>
<col><c>return<><><col>Return A Value<>
<col><c>Self<><><col>Alias For Type Being Defined or Being Implemented<>
<col><c>self<><><col>Method Subject or Current Module<>
<col><c>static<><><col>Global Variable<>
<col><c>struct<><><col>Defines a Structure<>
<col><c>super<><><col>Parent Module<>
<col><c>trait<><><col>Defines a Trait<>
<col><c>true<><><col>Boolean Literal<>
<col><c>try<><><col><s>(For Future Use)<><>
<col><c>type<><><col>Defines an Alias<>
<col><c>typeof<><><col><s>(For Future Use)<><>
<col><c>union<><><col>Defines a Union<>
<col><c>unsafe<><><col>Enables Unsafe Operations<>
<col><c>unsized<><><col><s>(For Future Use)<><>
<col><c>use<><><col>Bring Into Scope<>
<col><c>virtual<><><col><s>(For Future Use)<><>
<col><c>where<><><col>Type Constraint<>
<col><c>while<><><col>Conditional Loop<>
<col><c>yield<><><col><s>(For Future Use)<><><><>
@
@ abstract, as, async, await, become, box
@ break, const, continue, crate, do, dyn
@ else, enum, extern, false, final, fn
@ for, if, impl, in, let, loop, macro
@ match, mod, move, mut, override, priv
@ pub, ref, return, Self, self, static
@ struct, super, trait, true, try, type
@ typeof, union, unsafe, unsized, use
@ virtual, where, while, yield
@ keywords, reserved words



### Keyword - pub
Defines a function, type or module as public.

The default visibility is private.

<cb>pub fn <v>public_function_1<>() {
	<v>...<>
}<>



# Reference - Cargo.toml

Rust Docs: <l https://doc.rust-lang.org/cargo/reference/manifest.html>Cargo Format Specification<>
@
@ cargo.toml-only, settings


### Setting - Project Name

<cb>[package]
name = "<v>project_name<>"<>

Used by crates.io.


### Setting - Authors

<cb>[package]
authors = ["<v>Author 1<>", "<v>Author 2<>", "<v>Author 3<>"]<>


### Settings - Include Library

<cb>[dependencies]
<v>library_name<> = { path = "<v>path/to/libary<>" }<>

Includes a local Rust library in the workspace.
@
@ file system, add, local, dependencies, path


### Setting - License

<cb>[package]
license = "<v>license-type"<>


The license type must be a standard SPDX license id.

License SPDX IDs:
<l>https://spdx.org/licenses/<>


### Setting - Library File Name - Set / Override

<cb>[lib]
path="src/<v>new_name.rs<>"<>

Overrides the defaul "lib.rs" name for the main library file.

This helps remove confusion when working on multiple libraries all listed as 'lib' in your IDE.
@
@ lib.rs, change, [lib], path=



### Setting - Version

<cb>[package]
version = "<v>1<>.<v>2<>.<v>3<>"<>

Uses Semantic Versioning:

<cb><v>major<>.<v>minor<>.<v>patch<><>

Semantic Versioning: <l>https://semver.org/<>



# Reference - Coming From Other Languages


### Classes
Rust does not support classes.

Use <l "?=struct-only">structures<> and <l "?trait-only">traits<> instead.



### Class Constructors
Rust does not support constructors.

Implement a static function called <c>new<> instead.
<c>new<> is by convention.

Example:

<cb>pub struct <v>Item<> {
	pub <v>id<>: usize,
	pub <v>name<>: Option\<String>
}

impl <v>Item<> {
	pub fn new(<v>name<>: &str) {
		let <v>id<> = <v>next_id_function<>();
		<v>Item<> {
			<v>id<>: <v>id<>,
			<v>name<>: Some(<v>name<>.to_owned())
		}
	}
}<>



### Dictionary, Map

Use: HashMap
@
@ dict, dicts, maps



### Dictionary, Map - Sorted

Use: BtreeMap
@
@ dict, dicts, maps, ordered



### Lists

Use: <l "array-only">Array (immutable sequence)<>, <l "vec-only">Vec (mutable sequece)<>



# Acronyms


### ADT
Algebraic Data Type



### ARC
Atomically Reference Counted

See: <l "#arc">ARC<>



### COW
Clone on Write



### DST
Dynamically Sized Type



### HOF
Higher Order Functions



### MPSC
Multi-Producer Single-Consumer


### RAII
Resource Acquisition Is Initialization
@
@ RALL



### RC
Reference Counted

See: <l "#rc">RC<>



### SPDX
Software Package Data Exchange



# Terms
@
@ glossary, definition


### Algebraic Data Type (ADT)
A kind of composite type.

Contains 2 types:

Sum Type
Product Type



### Algebraic Data Types - Product Type
An item contains one or more items. A has a B and a C (contains fields).

Rust implements product types using structs.



### Algebraic Data Types - Sum Type
An item is a variation of something. It is one of a limited set.  A is a B or A is a C (variants).

Rust implements sum types using enums.



### Attribute
Metadata that relates to some crate, module or item.

It is used by the compiler.



### Borrow Checker
A component of the compiler that tracks lifetime and borrowing of a resource.

It ensures the borrows are valid and end before the owner is destroyed.



### Box
A smart pointer that allocates and then points to data on the heap.



### Cargo
Rust's build system and package manager.



### Clippy
Rust's includehd code linter.
@
@ lint, linter



### Crate
A compiled unit of a program.
A libary that can be pulled into a project. Includes a list of dependencies.



### Destructor
An object's destructor releases any owned resources, freeing up memory.

Rust automatically calls an objects destructor when the object goes out of scope.
Rust calls the <c>Drop<> trait to execute the destructor.
@
@ drop



### Dynamic Dispatch
Where Rust determines the trait functions to call dynamically at runtime.


Used when the trait is known but not the actual type until runtime.
Rust implements a vtable lookup to find the correct function to call.



### Dynamically Sized Type (DST)

Also Called: Unsized Type
@
@ unsized type



### Epoch
The time at Unix Time 0.

January 1st, 1970 at 00:00:00 UTC.
@ 
@ unix time



### Epoch Time / Unix Time
The time that has passed in seconds since the Unix epoch (January 1st, 1970).



### Expression
Something that evaluates to a value.



### Fat Pointer
Used to track an instance that implements a trait but the actual instance isn't known until runtime.

Consists of 2 internal pointers, one pointing to the data, the other pointing to the vtable for the Trait methods.

<cb>&dyn <v>Trait1<><>



### Ferris
The unofficial mascot of Rust
@
@ mascot



### Function Overloading
Not supported in Rust.

Use traits instead.



### Higher Order Functions (HOF)

These do either or both:

<*>Take One or More Functions as Parameters
Return a Functions<>



### Implicit Casting
Not supported in Rust.

Always explicitly cast your variables.



### Method - Instance Method

This is a method associated with an instance of a type and is accessed with the <c>.<> operator.



### Method - Static Method

This is a method associated with a type and is accessed with the <c>::<> operator.



### Method Overloading
Not supported in Rust.

Use traits instead.



### Module
A group of functions and types within a crate.



### Multi-Producer Single-Consumer (MPSC)
A first in first out (FIFO) queue used to communicote between threads.



### Panic
An unrecoverable error.



### Pointer
A variable that points to a location on the memory heap.

Pointers are stored in the stack.

<cb>*pointer<>



### Primitive
A data type built into the language.



### Resource Acquisition Is Initialization (RAII)
This simply means the constructor aquires a resource, the destructor releases it.

Rust enforces this. So when a resource goes out of scope, it's destructor is called and the resource is released.

(yes, RAII is a terrible name)


### Rustacean
Someone who likes and uses Rust.



### RustC
Rust's compiler.


### RustFMT
Rust's included code formatting tool.
@
@ formatter, fmt



### Rustup
Rust's included installer and Rust version switcher.

<l>https://rustup.rs<>



### String Slice
The name for the <c>&str<> data type.



### Statement
A command that performs some action but does not return a value.
This is usually in aid of evaluating an expression.



### Threads - Green Threads
A thread that runs concurrently (not true parallel) and is controlled by program.

Multiple green threads will run concurrently on a single native thread.

Rust supports this through 3rd party libraries.



### Threads - Native / OS Thread
A thread that runs in parallel and is controlled by the operating system.

Core Rust only supports native threads.



### Unit
An empty tuple.

These are returned by functions that do not return any value.



### vtable
Defines details for a type instance that implements a trait but the actual type isn't knovw until runtime.

Referenced from a fat pointer (<c>&dyn <v>Trait1<><>).
Each trait defines a separate vtable.


