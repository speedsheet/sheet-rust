# Rust Next


# Next

Rust Async


# Short Tutorials

<*>Control 
Formatting (Include formatting library)
String Slicing (first, mid, last)
Guard Statements?
Rust Design Patterns?
String Functions
Literals<>



# Add Guide

### Box - Expand on Why/When to Use

<*>Passing large data structures
dynamic dispatch (Box<dyn Trait>)
long living data
ownership and passing by reference
recursive functions
Size not known at compile time<>



# Add Next



### Guards - Releasing

- automatic
- once guard goes out of scope.



### Pointer Lookup

Pin


PartialOrd
Ord

Operator Oveloading \<, \<=. >, >=
	Requires PartialOrd



### Try From

<l>https://doc.rust-lang.org/std/convert/trait.TryFrom.html<>



## Control Statement Break


### For - Break label

Test:

<cb>'<v>label<>: for {
	<v>...<>
	break '<v>label<>
	<v>...<>
}<>



### All - Break label

Test:

<cb>'<v>label<>: ... {
	<v>...<>
	break '<v>label<>
	<v>...<>
}<>



### While - Break label

Test:

<cb>'<v>label<>: ... {
	<v>...<>
	break '<v>label<>
	<v>...<>
}<>



### Break with value

<cb>let <v>result<> = for {
	<v>...<>
	break <v>value<>
	<v>...<>
}<>



# .cmp() Function

Presumably on all primitive types:

<cb>= <v>value-1<>.cmp(<v>value-2<>)<>

Compares two values against eachother.



# matches!() macro

<cb>matches!(<v>value<>, <v>pattern<>)<>

Tests if a value matches a pattern.

Like a match statement but for concise single test matches.



# Rust Docs

Rust Docs: <l "https://doc.rust-lang.org/std/index.html">std<>::


# Mentors

Awesome Rust Mentors - github:

<l>https://rustbeginners.github.io/awesome-rust-mentors/<>


# Rust Docs / No Boiler Plate


### The Rust Programming Language (Book)
<l>https://doc.rust-lang.org/stable/book/<>

### Rust By Example
<l>https://doc.rust-lang.org/rust-by-example/<>

### Rustlings / Rust Katas
<l>https://github.com/rust-lang/rustlings<>

### Rust Cheatsheet
<l>https://cheats.rs/<>



# Higher-Rank Trait Bounds (HRTBs)

<l>https://doc.rust-lang.org/nomicon/hrtb.html<>


# Thoughts


## Good


### Rust Doesn't Store Types in the Runtime

Types are optimized out of existance by the compiler.
vtables are used when dynamic linking is needed.



### Man am I Bad at Pointers

Thought I'd be good with them...

But the borrow checker is a harsh mistress.
Straightens you out fast!

I miss references all over the place!!!



### Trait Allow Additional Functionality

You can apply a trait and its implementation to any struct.



### Enums / Sum Types

Finally a language that supports sum types!



### Option Type

Can't say why I like it better than dealing with nulls, but I do.
My code handles nulls pretty well. It is rarely an issue for me.
But even still, I really like Option!

Is it the explicit?



### Pattern Matching

match ... {

}



### Cargo

An amazing tool.
Coming from Java and Maven / Gradle, Cargo blows it out of the water.
Same with Python and its build tools!



### Type Aliasing!



## Bad


### Rust Traits ‚â† Interfaces

The spec, not the object.

They define the spec.
But they can never be instantiated as a type.

(whereas as long as a class implements an interface, you can pass the class in anywhere the interface can go).



### The Curse of Pointer Types

There is no way to avoid this.
If you are doing anything moderately complicated, using shared mutable anything or a library that requires types to support shared mutability, you  will need to learn and understant:

Box
RC
Rc\<RefCell>
Arc
Arc\<Mutex>
Guard

Cell
Ref
RefCell
RefMut
Weak
Cow

Mutex

This gets in the way of actually coding what you want.



### Can't Pass by Trait

You cant just pass by trait.
The compiler needs to know the actual instance.
- or you have to send Box\<dyn Trait>!



### String / str / unicode

Can't do string manipulation without understanding

Strings vs &str
And that Unicode is everything

Sure benefits...
	works way better than Java on unicode data.



### Lots of Looking Up / Must Lookup Functions / Types

To use a type, you need to have the definition in front of you.

Too many important details can not be guessed.
- is it pass by pointer?
- does it take ownership?
- what traits must be implemented?
- what return type is used?
- if <c>Result<>, standard <c>Result<>? Some custom <c>Result<>? What?



### Custom Errors, Custom Results Everywhere

Every library defines it's own <c>Result<>.
This is confusing. You must check.
- what <c>Result<> is it?
- what type of error does it return?
- what do I need to do to convert it to what i need?

Same for Errors.



### Borrow Checker - Unreadable Order of Lines

Need to be very careful about the order of events.
This often leads to code that looks disjointed as you duck and weave through borrow checker errors to ensure the data ends up where it needs to go.


### Borrow Checking - Gets Complicated Real Fast!

How do you copy &HashSet\<Rc\<String>> into Vec\<String>?
I'll wait.

<cb>let mut items: Vec\<String> = self
	.set
	.iter()
	.map(|value| value.to-string())
	.collect();<>



### Lifetimes

Add a lot of cognative overload to programming.
Add a lot of noise to type signatures.



## Ugly


### Rust is Pedantic!

Everything Is Different:

<*>Strucs Instantiated With {}, but Tuples With ()
Types Defined with ':', but fn Returns with -><>

Types and Sizes Must Be Known:

<*>Makes Dynamic Programming Verbose
Needs to absolutely know what a type is or it will not be happy.<>

<*>Traits Can Not Be Directly Treated as Types<>



### Rust Types are Noisy

They are long, and hard to parse.
High cognative load.

<cb>Vec\<Box\<dyn <v>module<>::<v>type<>::<v>Type<>>><>


Passing is even worse!

@
@ noisy



### Mut Parameter Type Inconsistency

<cb>fn function-1(mut item: Type)<>

<cb>fn function-1(item: &mut Type)<>

Really???

Nope: (item: mut Type)
Nope: (&mut item: type)



### Module Files

Wish the file structure were the file system.


### Rust Forces You To Deal With Issues

No way around it,
the compiler will force you to handle issues.


Not great for prototyping.
Will make your head hurt.
But the results....
	unbelievable!



# std::prelude

<l>https://doc.rust-lang.org/nightly/std/prelude/index.html<>



# Farmatted Print with named Arguments

Chat Gippity:

<card> This feature is called "formatted print with named arguments." It‚Äôs pretty slick and makes the code both cleaner and more readable. Here‚Äôs how it works:

<*><b>Declaring Variables:<> Just like in your snippet, you first declare and initialize your variables.
<b>Using Named Arguments:<> Inside the println! macro, you use curly braces {} to specify where to substitute the values of variables. By putting a variable name directly inside the braces (like {a}), Rust replaces it with the variable's value when the println! is executed.<>

This feature is especially handy when you have multiple variables to print in a single statement, as it avoids the confusion of positional arguments and makes your code more self-documenting. Rust handles all the magic under the hood to make sure the values align with the named placeholders. So, yep, you‚Äôre good to go with this syntax!<>



# File Seeking

### SeekFrom

<l>https://doc.rust-lang.org/std/io/enum.SeekFrom.html<>


### Seek.stream-position

<l>https://doc.rust-lang.org/std/io/trait.Seek.html#method.stream-position<>


### BufReader

+ Seek

### BufWriter

+ Seek

<m>Test with seek<>



# Atomic Counters

use std::sync::atomic::{AtomicBool, Ordering};

use std::sync::atomic::AtomicUsize;
use std::sync::atomic::Ordering;


atomicUsive.add-fetch()


https://doc.rust-lang.org/std/sync/atomic/


https://docs.rs/atomic-counter/latest/atomic-counter/



# RWLock

<t><h>Action<|>Method/Code<|>Description<>
Create RwLock<|><c>let lock = RwLock::new(value);<><|>Initializes a new RwLock with the given value.
Get Read Guard<|><c>let read-guard = lock.read().unwrap();<><|>Acquires a read lock, allowing shared access.
Get Write Guard<|><c>let mut write-guard = lock.write().unwrap();<><|>Acquires a write lock, allowing exclusive access.
Read Value<|><c>let value = *read-guard;<><|>Reads the value protected by the RwLock.
Update Value<|><c>*write-guard = new-value;<><|>Updates the value protected by the RwLock.
Downgrade Write Guard to Read Guard<|><c>let read-guard = RwLockWriteGuard::downgrade(write-guard);<><|>Downgrades a write guard to a read guard.
Try to Get Read Guard<|><c>if let Ok(read-guard) = lock.try-read() { ... }<><|>Tries to acquire a read lock without blocking.
Try to Get Write Guard<|><c>if let Ok(write-guard) = lock.try-write() { ... }<><|>Tries to acquire a write lock without blocking.
Unlock Read Guard<|><c>drop(read-guard);<><|>Explicitly releases a read lock.
Unlock Write Guard<|><c>drop(write-guard);<><|>Explicitly releases a write lock.
Check if Locked<|><c>lock.is-poisoned();<><|>Checks if the lock is poisoned due to a panic<>



# Pin

<t><h>Action<|>Method/Code<>
Create a Pin<|><c>let <v>pinned<>: Pin\<Box\<<v>T<>>> = Box::pin(<v>value<>);<>

Access Value<|><c>let <v>reference<>: &<v>T<> = Pin::get-ref(&<v>pinned<>);<>

Access Data mutably<|><c>let <v>mut-reference<>: Pin\<&mut <v>T<>> = Pin::as-mut(&mut <v>pinned<>);<>

Projecting to a field<|><{}><c>``` let <v>field<>: Pin\<&mut Field> = unsafe {
	<v>pinned<>.map-unchecked-mut(			<#>// ... remaining code is missing / incomplete<>
}<><>

Unpinning a value<|><c>impl Unpin for <v>Type1<> {}<>

Pinning an Arc or Rc<|><{}><c>let <v>pinned<>: Pin\<Arc\<<v>T<>>> = Arc::pin(<v>value<>);

let <v>pinned<>: Pin\<Rc\<<v>T<>>> = Rc::pin(<v>value<>);<><>

Using Pin in a struct<|><{}><c>struct <v>Struct1<> {
	<v>field<>: Pin\<Box\<<v>T<>>>
}

impl <v>Struct1<> {
	fn new(<v>value<>: <v>T<>) -> Self {
		Self {
			field: Box::pin(<v>value<>)
		}
	}
}<><>

Creating a pinned future<|><{}><c>async fn <v>example<>() -> <v>T<> {
	<v>...<>
}
let <v>pinned-future<> = Box::pin(example());<><>

Implementing Drop safely<|><{}><c>impl Drop for <v>Type1<> {
	fn drop(&mut self) {
		<#>/* only use self if your type is Unpin */<>
	}
}<><>

Pinning slices<|><c>let <v>slice<>: Pin\<&mut [<v>T<>]> = Pin::new(&mut <v>array<>[..]);<>

Pinning with references<|><{}><c>let <v>pinned-ref<>: Pin\<&<v>T<>> = Pin::new(<v>reference<>);

let <v>pinned-mut-ref<>: Pin\<&mut <v>T<>> = Pin::new(reference-mut);<><><>


# Rust Design Patterns

<l>https://rust-unofficial.github.io/patterns/<>


# Rust Design Patterns - Expand with Examples

Trait Extension Pattern

Type State
Interior mutability
RAIL
Builder


Arc\<[T]> over Vec\<T>
Arc\<str> over String


# Cell

Mutate Existing Value
Get Copy of Value


cell::new()
cell.get()
cell.set()


# Rust Training


### Traits

Structure
Implement - Static Functions
Implement - Structure Functions

Trait - Define
Trait - Implement


### Trait - Dynamic

Define
Create
Pass
Return


### Generics

Write Syntax Structure

Function - Generic Parameter
Function - Return Generic

Struct - Define
Struct - Create
Struct - Use

Trait - Define With Generics
Trait - Implement with Generics
Trait - Create
Trait - Use


### Lifetimes

Write Syntax Structure

Function Parameter
FUnction Return

Struct Define
Struct Use

Trait Define
Trait Use



# Common / Useful Crates

<l>https://blessed.rs/crates<>



# Add


## Format

<cb>format!("", )<>

Must implement a formatting trate (Display)


Rust Docs: <l https://doc.rust-lang.org/std/index.html>std<>::<l https://doc.rust-lang.org/std/macro.format.html>format!<>
Rust Docs: <l https://doc.rust-lang.org/std/index.html>std<>::<l https://doc.rust-lang.org/std/fmt/index.html>fmt<>



## Modules and Crates


### Commands

<cb>mod <v>name<><>

<cb>use <v>name<>:: <v>...<>;<>

Wild Card

<cb>use <v>name<>::*;<>


### Internal Module

<cb>mod {
}<>


### File Structure Modules

main.rs:

<cb>mod <v>filename<><>

- exclude .rs extension



## Generic Trait - Where Clause

<cb>... \<T, U>
	where
		T: BoundTrait1 + BoundTrait2,
		U: BoundTrait3 + BoundTrait4<>



# Next - Smart Pointers

Read Official Doc:
<l>https://doc.rust-lang.org/book/ch15-01-box.html<>


Article on Smart Pointers:
<l>https://blog.logrocket.com/smart-pointers-rust/<>



# * vs &

Article:
<l>https://stackoverflow.com/questions/36335342/meaning-of-the-ampersand-and-star-symbols-in-rust<>



# Comments

/// Outer line doc comment,1 BK EX REF use these on types, traits, functions, ‚Ä¶
//! Inner line doc comment, mostly used at start of file to document module.
//  Line comment, use these to document code flow or internals.
/* ‚Ä¶ */ Block comment. 2 üóëÔ∏è
/** ‚Ä¶ */    Outer block doc comment. 2 üóëÔ∏è
/*! ‚Ä¶ */    Inner block doc comment. 2 üóëÔ∏è



# COW, Str vs String, 'static

Good description:
<l>https://stackoverflow.com/questions/25754863/how-to-create-a-rust-struct-with-string-members<>



# COW

Holy Cow (Article):
<l>https://llogiq.github.io/2015/07/09/cow.html<>



# Yoke

<l>https://docs.rs/yoke/latest/yoke/struct.Yoke.html<>
@
@ serialize, deserialize, memory, 



# Arrays


### Array Slicing

<l>https://doc.rust-lang.org/rust-by-example/flow-control/match/destructuring/destructure-slice.html<>



# Destructuring

Official Docs:
<l>https://doc.rust-lang.org/rust-by-example/flow-control/match/destructuring.html<>


### Destructure Array


### Destructure Vec


### Destructure Iterator

use <c><v>iterator<>.take(<v>n<>)<>



# Default



### Default In Practice



### Constructor Using Default Fields

Using <c>..<> syntax.

<cb>= <v>Item1<> {
	updated-field = <v>value<>
	..
}<>


.. will use the default function to fill in the gaps üëç.



# Mutex



### Mutex - Update Reference

<l>https://stackoverflow.com/questions/45985827/how-can-i-replace-the-value-inside-a-mutex<>



# Design Patterns

Good Source:
Rust Unofficial Guide:

<l>https://rust-unofficial.github.io/patterns/patterns/index.html<>



# Rust Advice from Reddit

<l>https://www.reddit.com/r/rust/comments/13k6063/rust-most-fun-language/<>


A common approach is to just direct another Attack of the Clones if you don't have time to "fight borrow checker" for now :)

This, and Arc\<Mutex\<->> helps to speed up getting MVP in Rust.





impl Into<Cow<str>>


( source for this, example? )



# Terms


### Terms - Associated Type


### Terms - vs generic


### Define - Trait Object


### Define - dyn Trait


### Explain - 'static

See:
<l>https://stackoverflow.com/questions/25754863/how-to-create-a-rust-struct-with-string-members<>


### Explain - '-


### Explain - ?Sized



# Learn

Traits
Macros
Modules
Pre Processors
Unit Tests
Cargo


# Cheat Sheet

### Rust Cheat Sheet
<l>https://cheats.rs/<>



### Rust Cheat Sheet - Phaiax / Github
<l>https://phaiax.github.io/rust-cheatsheet/<>



# Add:

	destructuring
		let (a, b) = ...


Symbols / Operators:
<l>https://doc.rust-lang.org/book/appendix-02-operators.html<>

Primitives:
<l>https://doc.rust-lang.org/rust-by-example/primitives.html<>

Rust by Example (Docs):
<l>https://doc.rust-lang.org/rust-by-example/index.html<>

<in 2>Next (Conversion):
<l>https://doc.rust-lang.org/rust-by-example/conversion/from-into.html<>

char:
<l>https://doc.rust-lang.org/std/primitive.char.html<>

float:
<l>https://doc.rust-lang.org/std/primitive.f32.html<>

Array Slicing:
<l>https://doc.rust-lang.org/rust-by-example/primitives/array.html<>

Enums With Properties:
<l>https://doc.rust-lang.org/rust-by-example/custom-types/enum.html<>

Match Destructuring:
<l>https://doc.rust-lang.org/rust-by-example/flow-control/match/destructuring.html<><>



### Use Module

<cb>use <v>module<>::<v>component<>;<>

<m>(Incorporate)<>
@
@ import


#### Module Structure

<l>https://www.reddit.com/r/rust/comments/ujry0b/media-how-to-create-a-module-hierarchy-in-rust/<>



### Memory

Fixed at runtime

Space Precalculated by compiler
Stack variables must have known size at compile time
Stack Frame - > local variable
Stack frame -> removed when function exits

Heap:
Dynamic
Can grow shrink at runtime



# Cheat Sheet
<l>https://cheats.rs/<>


# Lifetimes


### Lifetimes - Good Article
<l>https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md<>

Covers:

<cb><v>T<>, &<v>T<>, &mut <v>T<>
'static<>
@
@ static


#### Lifetime Article - Generics

<c><v>T<><> is a superset of <c>&<v>T<>, &mut <v>T<><>

<c>&<v>T<>, &mut <v>T<><> are disjoint sets<>


No:

<cb>trait Trait {}

impl\<<v>T<>> Trait for <v>T<> {}

impl\<<v>T<>> Trait for &<v>T<> {}          <#>// ‚ùå<>

impl\<<v>T<>> Trait for &mut <v>T<> {}      <#>// ‚ùå<><>


Yes:

<cb>trait Trait {}

impl\<<v>T<>> Trait for &<v>T<> {}          <#>// ‚úÖ<>

impl\<<v>T<>> Trait for &mut <v>T<> {}      <#>// ‚úÖ<><>




#### Lifetime Article - 'static

Rules:

<*>they can only be created at compile-time
they should be immutable, mutating them is unsafe
they're valid for the entire program<>


# Attributes

Official Docs:
<l>https://doc.rust-lang.org/reference/attributes.html<>


## Attributes - Built In:

List of:

<l>https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index<>


## Attributes - Macros

<l>https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros<>


## Attributes - Derive Macro Helper

<l>https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes<>



## Attributes - Tool

<l>https://doc.rust-lang.org/reference/attributes.html#tool-attributes<>



# Coercios

Article: What can and can not be coerced:
<l>https://www.possiblerust.com/guide/what-can-coerce-and-where-in-rust<>


Official Docs:
<l>https://doc.rust-lang.org/reference/type-coercions.html<>
@
@ coersion




# Wrapper Types
@
@ box, rc, arc, cell, refcell


### Wrapper Types - Box vs RC vs Arc vs Cell

<table><col><c>Box\<<v>T<>><><><col>Single Owner, Heap Allocation<><col><l https://doc.rust-lang.org/std/boxed/struct.Box.html>Rust Docs<><>
<col><c>Rc\<<v>T<>><><><col>Multiple Owners, Not Thread Safe<><col><l https://doc.rust-lang.org/std/rc/struct.Rc.html>Rust Docs<><>
<col><c>Arc\<<v>T<>><><><col>Multiple Owners, Thread Safe<><col><l https://doc.rust-lang.org/std/sync/struct.Arc.html>Rust Docs<><>
<col><c>Cell\<<v>T<>><><><col>"Interior Mutability"
Use to Mutate Data Behind &\<<v>T<>><><col><l "https://doc.rust-lang.org/std/cell/struct.Cell.html">Rust Docs<><><>


<c>Box\<<v>T<>><>		Single Owner, Heap Allocation						<l https://doc.rust-lang.org/std/boxed/struct.Box.html>Rust Docs<>
<c>Rc\<<v>T<>><>		Multiple Owners, Not Thread Safe						<l https://doc.rust-lang.org/std/rc/struct.Rc.html>Rust Docs<>
<c>Arc\<<v>T<>><>		Multiple Owners, Thread Safe						<l https://doc.rust-lang.org/std/sync/struct.Arc.html>Rust Docs<>
<c>Cell\<<v>T<>><>		"Interior Mutability" - Use to Mutate Data Behind &\<<v>T<>>		<l "https://doc.rust-lang.org/std/cell/struct.Cell.html">Rust Docs<>


(RC = Reference Counter)
(ARC = Atomic Reference Count)



### Wrapper Types - Box vs RC vs Arc vs Cell vs RefCell vs Mutex vs RwLock - Article

Good explanation:
<l>https://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/<>



# Not in Rust

Not In Core Rust


### Date, DateTime




### Random

Use Rand <l>rust-rand<>



# Modules


### Module - Add Path To Scope

<cb>use <v>path<>;<>

<cb>use <v>path<>::<v>path<>::{<v>item1<>, <v>item2<>, <v>item3<>};<>

<cb>use <v>path<> as <v>alias<>;<>

Imports a path into the current namespace.



Create Root

	App / Binary:

		main.rs

	Library:

		lib.rs


### Crate Terms

#### Package

A collection of 1 or more crates.
use to build, test, release creates
contains a Cargo.toml file describing the crates, build processes etc.

#### crate

a tree of module that combine into one app or library.
Typically refers to a Library Crate.

#### Crate


A compressed file
Contains the source code of the library crate.


#### Library Crate

A crate that is to be used by other programs.

#### module

A namespace for a collection of related code.

#### Module Definition


model path != directory path



#### Path

Identifes a particular module or code item



#### Crate Root:

Use: Binds path to current scope




## Modules


### Modules - Add To Root

main.rs / lib.rs:

<cb>mod <v>module-1<>;<>

Searches:

	Root File (main.rs, lib.rs):

		mod <v>module-1<> { <v>...<> }

	File: src/<v>module-1<>.rs

	File: src/<v>module-1<>/mod.rs


	crate::

		the root of the current module


### Modules - Add To Parent Current

Parent rs file:

<cb>mod <v>module-1<>;<>

Searches:

	Parent File:

		mod <v>module-1<> { <v>...<> }

	File: ./<v>module-1<>.rs

	File: ./<v>module-1<>/mod.rs




### Module Path

Module Path ‚â† File Path


Module Path Declared Through Code


### Module - Define

main.rs

	mod dir;

dir/mod.rs

	...



### Module - Define, Reference Sub Module

main.rs

	mod dir;
	use dir::dir-mod;

dir/mod.rs

	mod dir-mod;

dir/mod-dir.rs

	...

		


# Data Types (Built In)



### Duration

Type:

<cb>std::time::Duration<>

Rust Docs: <l https://doc.rust-lang.org/std/time/struct.Duration.html>Duration<>
@
@ std::time::Duration



### Instant

<cb>= Instant::now()<>

Type:

<cb>std::time::Instant<>

Rust Docs: <l https://doc.rust-lang.org/std/time/struct.Instant.html>Instant<>
@
@ std::time::Instant



### SystemTime

<cb>= SystemTime::now()<>

Type:

<cb>std::time::SystemTime<>

Rust Docs: <l https://doc.rust-lang.org/std/time/struct.SystemTime.html>SystemTime<>
@
@ std::time::SystemTime


### Time - Unix Epoch

Type:

<cb>std::time::UNIX-EPOCH<>

Rust Docs: <l https://doc.rust-lang.org/std/time/constant.UNIX-EPOCH.html>SystemTime<>
@
@ std::time::UNIX-EPOCH




# Dynamic Dispatch

Good source of information, Details:

<l>https://articles.bchlr.de/traits-dynamic-dispatch-upcasting<>




# Next 2



String is the dynamic heap string type, like Vec: use it when you need to own or modify your string data.

str is an immutable1 sequence of UTF-8 bytes of dynamic length somewhere in memory. Since the size is unknown, one can only handle it behind a pointer. This means that str most commonly2 appears as &str: a reference to some UTF-8 data, normally called a "string slice" or just a "slice". A slice is just a view onto some data, and that data can be anywhere, e.g.


 A str is fixed-length; you cannot write bytes beyond the end, or leave trailing invalid bytes. Since UTF-8 is a variable-width encoding, this effectively forces all strs to be immutable in many cases. In general, mutation requires writing more or fewer bytes than there were before (e.g. replacing an a (1 byte) with an √§ (2+ bytes) would require making more room in the str). There are specific methods that can modify a &mut str in place, mostly those that handle only ASCII characters, like make-ascii-uppercase.

2 Dynamically sized types allow things like Rc<str> for a sequence of reference counted UTF-8 bytes since Rust 1.2. Rust 1.21 allows easily creating these types.




### * vs &

<l>https://stackoverflow.com/questions/36335342/meaning-of-the-ampersand-and-star-symbols-in-rust<>



# Errors


### Custom Error

Custom Error


<*>Use an Enum
Implement Error, Display<>



Example:

<cb>#[derive(Debug)]
enum CustomError {
	GeneralError {description: String},
	InvalidValue {description: String}
}

impl CustomError {
	fn general-error(original: Error) 
	fn inva lid-value(description: String) -> CustomError {
		Error::InvalidValue {description}
	}
	fn description(&self) -> String {
		match self {
			CustomError::Error {description} => {
				description.clone()
			}
			CustomError::InvalidValue {description} => {
				description.clone()
			}
		}
	}
}

impl std::error::error for Error {
}

impl fmt::Display for CustomError { 
	fn fmt(&self, f: &mut fmt::Formatter<'->) -> fmt::Result {
		write!(f, "({})", CustomError::description(self))
	}
}<>



### Error - Pass Generic Error

<cb>fn <v>function-1<>() -> Result\<<v>T<>, Box\<dyn std::error::Error>> {
	<v>...<>
}<>


### Error - Downcast / Get Type

Given:

<cb>match <v>some-result<> {
	err(<v>boxed-error<>) => {
		<#>// in here...<>
	}<>

Then:

<cb>if let Some(<v>unboxed-error<>) = <v>boxed-error<>.dowcast-ref::\<<v>Type<>>() {
	<v>...<>
}<>



### Error - Downcast - Example II

<cb>let <v>error<>: Box\<dyn std::error::Error> = <v>function-that-returns-error<>();

if let Some(err) = e.downcast-ref::\<<v>actual<>::<v>error<>::<v>Type<>>() {
	<v>...<>
}<>


Aricle:
<l>https://www.sheshbabu.com/posts/rust-error-handling/<>




# Pointer
A variable that stores the address of another variable.


https://www.koderhq.com/tutorial/rust/smart-pointer/



### Box\<T> vs &T

&T          Pointer -> T on heap | stack | binary
			borrower

Box\<T>      pointer -> T on heap
			owner


Box\<dyn T>  pointer -> T on Heap



### Derf
Smart pointer that customizes the behaviour of the derefrence operator

### Drop



### Pointers 2 - & vs * vs ref vs Box

Stack Overflow:
<l>https://stackoverflow.com/questions/31949579/understanding-and-relationship-between-box-ref-and<>



### Function as a Parameter

AI / Gipity Take:

<cb>Fn<>

<*>Can be called multiple times
Only immutable access to captured variables
Automatically implements FnMut and FnOnce (Fn is more restricive)<>

Must implement FnMut, FnOnce... what it means to say is that Fn is a more restrictive type and so automatically implements FnMut, FnOnce.

<cb>FnMut<>

<*>Can be called multiple times
Can mutate captured variables
Automatically implements FnOnce (FnMut is more restricive)<>

FnOnce

<*>Can be called once
Takes ownership of captured variables
All closures implement this (it's the base trait)<>


More AI:

<b>Function pointers vs closures:<>

<c>fn(...)<> = function pointer (no captures, can be called multiple times)
<c>Fn(...)<> = closure trait (can capture, called multiple times)
<c>FnOnce(...)<> = closure trait (can capture, called once)



# Compile


### Compile - Minimal Size

Github Notes:
<l>https://github.com/johnthagen/min-sized-rust<>

Stack Overflow:
<l>https://stackoverflow.com/questions/29008127/why-are-rust-executables-so-huge<>



### Compile - Target Environment / CPU

<m>Check that it is 'cargo install'<>

<cb>cargo install trunck<>

<cb>rustup target add wasm32-unknown-unknown<>
@
@ rustup target add


# Traits


### Traits - Must Have
Copy, Send, Sync, Sized, Unpin, Drop, Fn, FnMut, FnOnce, Clone, PartialEq, Eq, PartialOrd, Ord, AsMut, AsRef, From, Into, TryFrom, TryInto, Default, Iterator, IntoIterator, FromIterator, Extend, DoubleEndedIterator, ExactSizeIterator)

Any, Borrow, BorrowMut, ToOwned, Error, Debug, Display, Future, IntoFuture, Hash, Read, Write, Seek, FromStr, ToString 



# Linked List, Tree

Medium Article:
<l>https://medium.com/swlh/easy-persistent-data-structures-in-rust-b58334aeaf0a<>

Uses: RC, ARC



# Derive

<l>https://doc.rust-lang.org/rust-by-example/trait/derive.html<>

<*>Copy
Hash
Clone<>



# Operator Overloading / Implementation

<t striped grid><h>Trait Name<|>Syntax Feature<|>Description<|>Example<>
<c>std::ops::Add<><|><c>+<> (Addition)<|>Defines the behavior for the <c>+<> operator<|><c>a + b<>
<c>std::ops::Sub<><|><c>-<> (Subtraction)<|>Defines the behavior for the <c>-<> operator<|><c>a - b<>
<c>std::ops::Mul<><|><c>*<> (Multiplication)<|>Defines the behavior for the <c>*<> operator<|><c>a * b<>
<c>std::ops::Div<><|><c>/<> (Division)<|>Defines the behavior for the <c>/<> operator<|><c>a / b<>
<c>std::ops::Rem<><|><c>%<> (Remainder)<|>Defines the behavior for the <c>%<> operator<|><c>a % b<>
<c>std::ops::Neg<><|><c>-<> (Unary negation)<|>Defines the behavior for unary <c>-<><|><c>-a<>
<c>std::ops::Index<><|><c>[]<> (Indexing)<|>Allows indexing into a collection<|><c>collection[index]<>
<c>std::ops::IndexMut<><|><c>[]<> (Mutable Indexing)<|>Allows mutable indexing into a collection<|><c>collection[index] = value<>
<c>std::ops::Shl<><|><c>\<\<<> (Left shift)<|>Defines the behavior for left shift<|><c>a \<\< b<>
<c>std::ops::Shr<><|><c>>><> (Right shift)<|>Defines the behavior for right shift<|><c>a >> b<>
<c>std::ops::BitAnd<><|><c>&<> (Bitwise AND)<|>Defines bitwise AND operation<|><c>a & b<>
<c>std::ops::BitOr<><|><c>|<> (Bitwise OR)<|>Defines bitwise OR operation<|><c>a | b<>
<c>std::ops::BitXor<><|><c>^<> (Bitwise XOR)<|>Defines bitwise XOR operation<|><c>a ^ b<>
<c>std::ops::Not<><|><c>!<> (Bitwise NOT)<|>Defines bitwise NOT operation<|><c>!a<>
<c>std::ops::AddAssign<><|><c>+=<> (Addition assignment)<|>Defines <c>+=<> operator<|><c>a += b<>
<c>std::ops::SubAssign<><|><c>-=<> (Subtraction assignment)<|>Defines <c>-=<> operator<|><c>a -= b<>
<c>std::ops::MulAssign<><|><c>*=<> (Multiplication assignment)<|>Defines <c>*=<> operator<|><c>a *= b<>
<c>std::ops::DivAssign<><|><c>/=<> (Division assignment)<|>Defines <c>/=<> operator<|><c>a /= b<>
<c>std::ops::RemAssign<><|><c>%=<> (Remainder assignment)<|>Defines <c>%=<> operator<|><c>a %= b<>
<c>std::ops::BitAndAssign<><|><c>&=<> (Bitwise AND assignment)<|>Defines <c>&=<> operation<|><c>a &= b<>
<c>std::ops::BitOrAssign<><|><c>|=<> (Bitwise OR assignment)<|>Defines <c>|=<> operation<|><c>a |= b<>
<c>std::ops::BitXorAssign<><|><c>^=<> (Bitwise XOR assignment)<|>Defines <c>^=<> operation<|><c>a ^= b<>
<c>std::ops::Deref<><|><c>*<> (Dereferencing)<|>Allows dereferencing of a type<|><c>*ptr<>
<c>std::ops::DerefMut<><|>Mutable dereferencing<|>Allows mutable dereferencing<|><c>*mut-ptr = value<>
<c>std::cmp::PartialEq<><|><c>==<>, <c>!=<> (Equality)<|>Defines equality comparison<|><c>a == b<>, <c>a != b<>
<c>std::cmp::PartialOrd<><|><c>\<<>, <c>><>, <c>\<=<>, <c>>=<><|>Defines ordering comparisons<|><c>a \< b<>, <c>a > b<><>




# Libraries



### Date - Crono

<l>https://docs.rs/chrono/latest/chrono<>



### Serializing - Serde

Official:
<l>https://serde.rs/<>

Crate:
<l>https://crates.io/crates/serde<>



### Serializing - Serde JSON

<l>https://serde.rs/json.html<>



# Charts


### Memory Layout

<image "Rust container cheat sheet.svg">
@
@ smart pointers, 



